reset search_path;
create extension if not exists gms_utility;
create extension gms_output;
select gms_output.enable;
 enable 
--------
 
(1 row)

set behavior_compat_options="bind_procedure_searchpath";
-- start test db_version
declare
    version varchar2(50);
    compatibility varchar2(50);
begin
    gms_utility.db_version(version, compatibility);
    raise info 'version: %', version;
    raise info 'compatibility: %', compatibility;
end;
/
--?INFO:  version: openGauss.*
--?INFO:  compatibility: openGuass.*
declare
    version varchar2(50);
begin
    gms_utility.db_version(version);
    raise info 'version: %', version;
end;    -- error
/
ERROR:  function "db_version" with 1 parameters doesn't exist 
CONTEXT:  SQL statement "CALL gms_utility.db_version(version)"
PL/pgSQL function inline_code_block line 3 at SQL statement
call gms_utility.db_version();  -- error
ERROR:  function "db_version" with 0 parameters doesn't exist 
declare
    version int;
    compatibility int;
begin
    gms_utility.db_version(version, compatibility);
    raise info 'version: %', version;
    raise info 'compatibility: %', compatibility;
end;    -- error
/
--?ERROR:  invalid input syntax for integer:.*
CONTEXT:  PL/pgSQL function inline_code_block line 4 at SQL statement
-- end test db_version
-- start test get_cpu_time
select gms_utility.get_cpu_time();
 get_cpu_time 
--------------
--?.*
(1 row)

select gms_utility.get_cpu_time(100);   -- error
ERROR:  function gms_utility.get_cpu_time(integer) does not exist
LINE 1: select gms_utility.get_cpu_time(100);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: get_cpu_time
declare
    cputime char(1);
begin
    cputime := gms_utility.get_cpu_time();
    raise info 'cpuTimeDelta: %', cputime;
end;
/
ERROR:  value too long for type character(1)
CONTEXT:  PL/pgSQL function inline_code_block line 3 at assignment
declare
    cputime json;
begin
    cputime := gms_utility.get_cpu_time();
    raise info 'cpuTimeDelta: %', cputime;
end;
/
--?INFO:  cpuTimeDelta:.*
declare
    t1 number := 0;
    t2 number := 0;
    timeDelta number;
    i integer;
    sum integer;
begin
    t1 := gms_utility.get_cpu_time();
    for i in 1..1000000 loop
       sum := sum + i * 2 + i / 2;
    end loop;
    t2 := gms_utility.get_cpu_time();
    timeDelta = t2 - t1;
    raise info 'cpuTimeDelta: %', timeDelta;
end;
/
--?INFO:  cpuTimeDelta:.*
declare
    i number;
    j number;
    k number;
begin
    i := gms_utility.get_cpu_time;

    select count(*)
    into j
    from pg_class t, pg_index i
    where t.Oid = i.indexrelid;

    k := gms_utility.get_cpu_time;
    raise info 'costtime: %', (k-i);
end;
/
--?INFO:  costtime:.*
-- end test get_cpu_time
-- start test get_endianness
select gms_utility.get_endianness();
 get_endianness 
----------------
--?.*
(1 row)

select gms_utility.get_endianness(1000);
ERROR:  function gms_utility.get_endianness(integer) does not exist
LINE 1: select gms_utility.get_endianness(1000);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: get_endianness
-- end test get_endianness
-- start test get_sql_hash
declare
    hash    raw(50);
    l4b     number;
begin
    gms_utility.get_sql_hash('Today is a good day!', hash, l4b);
    raise info 'hash: %', hash;
    raise info 'last4byte: %', l4b;
end;
/
INFO:  hash: 834E5BE13C0240D4F1AEBB1BCE7205AF
INFO:  last4byte: 2936369870
declare
    hash    raw(50);
    l4b     number;
begin
    gms_utility.get_sql_hash(NULL, hash, l4b);
    raise info 'hash: %', hash;
    raise info 'last4byte: %', l4b;
end;
/
INFO:  hash: <NULL>
INFO:  last4byte: <NULL>
declare
    hash    raw(50);
    l4b     number;
begin
    gms_utility.get_sql_hash('', hash, l4b);
    raise info 'hash: %', hash;
    raise info 'last4byte: %', l4b;
end;
/
INFO:  hash: <NULL>
INFO:  last4byte: <NULL>
call gms_utility.get_sql_hash();
ERROR:  function "get_sql_hash" with 0 parameters doesn't exist 
-- end test get_sql_hash
-- start test is_bit_set
declare
	r raw(50) := '123456AF';
	result NUMBER;
	pos NUMBER;
begin
	for pos in 1..32 loop
		result := gms_utility.is_bit_set(r, pos);
		raise info 'position = %, result = %', pos, result;
	end loop;
end;
/
INFO:  position = 1, result = 1
INFO:  position = 2, result = 1
INFO:  position = 3, result = 1
INFO:  position = 4, result = 1
INFO:  position = 5, result = 0
INFO:  position = 6, result = 1
INFO:  position = 7, result = 0
INFO:  position = 8, result = 1
INFO:  position = 9, result = 0
INFO:  position = 10, result = 1
INFO:  position = 11, result = 1
INFO:  position = 12, result = 0
INFO:  position = 13, result = 1
INFO:  position = 14, result = 0
INFO:  position = 15, result = 1
INFO:  position = 16, result = 0
INFO:  position = 17, result = 0
INFO:  position = 18, result = 0
INFO:  position = 19, result = 1
INFO:  position = 20, result = 0
INFO:  position = 21, result = 1
INFO:  position = 22, result = 1
INFO:  position = 23, result = 0
INFO:  position = 24, result = 0
INFO:  position = 25, result = 0
INFO:  position = 26, result = 1
INFO:  position = 27, result = 0
INFO:  position = 28, result = 0
INFO:  position = 29, result = 1
INFO:  position = 30, result = 0
INFO:  position = 31, result = 0
INFO:  position = 32, result = 0
declare
	r raw(50) := '123456AF';
	result NUMBER;
	pos NUMBER;
begin
	for pos in 33..64 loop
		result := gms_utility.is_bit_set(r, pos);
		raise info 'position = %, result = %', pos, result;
	end loop;
end;
/
INFO:  position = 33, result = 1
INFO:  position = 34, result = 1
INFO:  position = 35, result = 1
INFO:  position = 36, result = 1
INFO:  position = 37, result = 0
INFO:  position = 38, result = 1
INFO:  position = 39, result = 0
INFO:  position = 40, result = 1
INFO:  position = 41, result = 0
INFO:  position = 42, result = 1
INFO:  position = 43, result = 1
INFO:  position = 44, result = 0
INFO:  position = 45, result = 1
INFO:  position = 46, result = 0
INFO:  position = 47, result = 1
INFO:  position = 48, result = 0
INFO:  position = 49, result = 0
INFO:  position = 50, result = 0
INFO:  position = 51, result = 1
INFO:  position = 52, result = 0
INFO:  position = 53, result = 1
INFO:  position = 54, result = 1
INFO:  position = 55, result = 0
INFO:  position = 56, result = 0
INFO:  position = 57, result = 0
INFO:  position = 58, result = 1
INFO:  position = 59, result = 0
INFO:  position = 60, result = 0
INFO:  position = 61, result = 1
INFO:  position = 62, result = 0
INFO:  position = 63, result = 0
INFO:  position = 64, result = 0
select gms_utility.is_bit_set(); -- error
ERROR:  function gms_utility.is_bit_set() does not exist
LINE 1: select gms_utility.is_bit_set();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: is_bit_set
select gms_utility.is_bit_set(NULL, 10); -- error
ERROR:  invalid input value
CONTEXT:  referenced column: is_bit_set
select gms_utility.is_bit_set('', 10);  -- error
ERROR:  invalid input value
CONTEXT:  referenced column: is_bit_set
select gms_utility.is_bit_set('123456'); -- error
ERROR:  function gms_utility.is_bit_set(unknown) does not exist
LINE 1: select gms_utility.is_bit_set('123456');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: is_bit_set
select gms_utility.is_bit_set('123456AF', 9);
 is_bit_set 
------------
          0
(1 row)

select gms_utility.is_bit_set('12345678AF', 9);
 is_bit_set 
------------
          0
(1 row)

select gms_utility.is_bit_set('123456TT', 9); -- error
ERROR:  invalid hexadecimal digit: "T"
LINE 1: select gms_utility.is_bit_set('123456TT', 9);
                                      ^
CONTEXT:  referenced column: is_bit_set
select gms_utility.is_bit_set('12345678TT', 9); -- error
ERROR:  invalid hexadecimal digit: "T"
LINE 1: select gms_utility.is_bit_set('12345678TT', 9);
                                      ^
CONTEXT:  referenced column: is_bit_set
select gms_utility.is_bit_set('1234', 9);
 is_bit_set 
------------
          0
(1 row)

select gms_utility.is_bit_set('12345678', -10); -- error
ERROR:  invalid second param value range
CONTEXT:  referenced column: is_bit_set
select gms_utility.is_bit_set('12345678', 0); -- error
ERROR:  invalid second param value range
CONTEXT:  referenced column: is_bit_set
select gms_utility.is_bit_set('12345678', 100);
 is_bit_set 
------------
          1
(1 row)

select gms_utility.is_bit_set('12345678', 3.14E100); -- error
ERROR:  integer out of range
CONTEXT:  referenced column: is_bit_set
select gms_utility.is_bit_set('团团又圆圆', 20); -- error
--?ERROR:  invalid hexadecimal digit:.*
LINE 1: select gms_utility.is_bit_set('团团又圆圆', 20);
                                      ^
CONTEXT:  referenced column: is_bit_set
select gms_utility.is_bit_set('12345678AF', null);
 is_bit_set 
------------
          0
(1 row)

select gms_utility.is_bit_set('F2345678AF', null);
 is_bit_set 
------------
          1
(1 row)

select gms_utility.is_bit_set('12345678AF', '');
 is_bit_set 
------------
          0
(1 row)

select gms_utility.is_bit_set('F2345678AF', '');
 is_bit_set 
------------
          1
(1 row)

declare
    raw_data raw(50) := hextoraw('ff11aa33');
    bit_position number := null;
    bit_status number;
begin
    bit_status := gms_utility.is_bit_set(raw_data, bit_position);
    raise info 'bit osition is: %', bit_status;
end;
/
INFO:  bit osition is: 1
declare
    raw_data raw(50) := hextoraw('ff11aa33');
    bit_position number := '';
    bit_status number;
begin
    bit_status := gms_utility.is_bit_set(raw_data, bit_position);
    raise info 'bit osition is: %', bit_status;
end;
/
INFO:  bit osition is: 1
-- end test is_bit_set
-- start test is_cluster_database
select gms_utility.is_cluster_database();
 is_cluster_database 
---------------------
 f
(1 row)

select gms_utility.is_cluster_database(1000);
ERROR:  function gms_utility.is_cluster_database(integer) does not exist
LINE 1: select gms_utility.is_cluster_database(1000);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: is_cluster_database
begin
	if gms_utility.is_cluster_database then
		raise info 'true';
	else
		raise info 'false';
	end if;
end;
/
INFO:  false
-- end test is_cluster_database
-- start test old_current_schema
select gms_utility.old_current_schema();
 old_current_schema 
--------------------
--?.*
(1 row)

select gms_utility.old_current_schema(2000);
ERROR:  function gms_utility.old_current_schema(integer) does not exist
LINE 1: select gms_utility.old_current_schema(2000);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: old_current_schema
-- end test old_current_schema
-- start test old_current_user
select gms_utility.old_current_user();
 old_current_user 
------------------
--?.*
(1 row)

select gms_utility.old_current_user(2000);
ERROR:  function gms_utility.old_current_user(integer) does not exist
LINE 1: select gms_utility.old_current_user(2000);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: old_current_user
-- end test old_current_user
---------------------------
-- expand_sql_text
---------------------------
create schema test_utility_est;
set search_path to test_utility_est;
declare
    sqlTxt CLOB;
begin
    gms_utility.expand_sql_text(NULL, sqlTxt);
    raise info 'output_sql_text: %', sqlTxt;
end;
/
INFO:  output_sql_text: <NULL>
declare
    sqlTxt CLOB;
begin
    gms_utility.expand_sql_text(NULL);
    raise info 'output_sql_text: %', sqlTxt;
end;
/
ERROR:  function "expand_sql_text" with 1 parameters doesn't exist 
CONTEXT:  SQL statement "CALL gms_utility.expand_sql_text(NULL)"
PL/pgSQL function inline_code_block line 3 at SQL statement
create table test_dx(id int);
create view view1 as select * from test_dx;
create materialized view mv_dx as select * from test_dx;
declare
    input_sql_text clob := 'select * from test_utility_est.view1';
    output_sql_text clob;
begin
    gms_utility.expand_sql_text(input_sql_text, output_sql_text);
    raise info 'output_sql_text: %', output_sql_text;
end;
/
INFO:  output_sql_text: SELECT id FROM (SELECT test_dx.id FROM test_utility_est.test_dx) view1
declare
    input_sql_text clob := 'select * from test_utility_est.view1;';
    output_sql_text clob;
begin
    gms_utility.expand_sql_text(input_sql_text, output_sql_text);
    raise info 'output_sql_text: %', output_sql_text;
end;
/
INFO:  output_sql_text: SELECT id FROM (SELECT test_dx.id FROM test_utility_est.test_dx) view1
-- don't expand materialized view sql, just print
declare
    input_sql_text clob := 'select * from test_utility_est.mv_dx';
    output_sql_text clob;
begin
    gms_utility.expand_sql_text(input_sql_text, output_sql_text);
    raise info 'output_sql_text: %', output_sql_text;
end;
/
INFO:  output_sql_text: SELECT id FROM test_utility_est.mv_dx
-- test multi sql, error
declare
    input_sql_text clob := 'select * from test_utility_est.view1;select * from test_utility_est.view1';
    output_sql_text clob;
begin
    gms_utility.expand_sql_text(input_sql_text, output_sql_text);
    raise info 'output_sql_text: %', output_sql_text;
end;
/
ERROR:  Expand_sql_text only support one query
CONTEXT:  PL/pgSQL function gms_utility.expand_sql_text(clob) line 2 at assignment
SQL statement "CALL gms_utility.expand_sql_text(input_sql_text,output_sql_text)"
PL/pgSQL function inline_code_block line 4 at SQL statement
-- test select into
insert into test_dx values (3);
declare
    num int := 0;
    input_sql_text clob := 'select * into t_into from test_utility_est.view1;';
    output_sql_text clob;
begin
    gms_utility.expand_sql_text(input_sql_text, output_sql_text);
    raise info 'output_sql_text: %', output_sql_text;
end;
/
INFO:  output_sql_text: INSERT INTO gms_utility.t_into (id) SELECT id FROM (SELECT test_dx.id FROM test_utility_est.test_dx) view1
declare
    num int := 0;
    output_sql_text clob;
begin
    gms_utility.expand_sql_text('select id into num from test_utility_est.view1', output_sql_text);
    raise info 'output_sql_text: %', output_sql_text;
end;
/
INFO:  output_sql_text: INSERT INTO gms_utility.num (id) SELECT id FROM (SELECT test_dx.id FROM test_utility_est.test_dx) view1
--test with select
declare
    num int := 0;
    input_sql_text clob := 'with ws (id) AS (select id from test_utility_est.view1) select * from ws';
    output_sql_text clob;
begin
    gms_utility.expand_sql_text(input_sql_text, output_sql_text);
    raise info 'output_sql_text: %', output_sql_text;
end;
/
INFO:  output_sql_text: WITH ws(id) AS (SELECT view1.id FROM (SELECT test_dx.id FROM test_utility_est.test_dx) view1) SELECT id FROM ws
-- test select for update
declare
    input_sql_text clob := 'select * from test_utility_est.test_dx for update';
    output_sql_text clob;
begin
    gms_utility.expand_sql_text(input_sql_text, output_sql_text);
    raise info 'output_sql_text: %', output_sql_text;
end;
/
INFO:  output_sql_text: SELECT id FROM test_utility_est.test_dx FOR UPDATE OF test_dx
declare
    input_sql_text clob := 'select * from test_utility_est.view1 for update';
    output_sql_text clob;
begin
    gms_utility.expand_sql_text(input_sql_text, output_sql_text);
    raise info 'output_sql_text: %', output_sql_text;
end;
/
INFO:  output_sql_text: SELECT id FROM (SELECT test_dx.id FROM test_utility_est.test_dx) view1 FOR UPDATE OF view1
create table test_1(id int, name varchar(20));
create table test_2(id int, name varchar(20));
create view view2 as select * from test_1;
create view view3 as select * from test_1 union select * from test_2;
create view view4 as select * from test_1 union select * from view3;
declare
 input_sql_text1 clob := 'select * from test_utility_est.view3';
 output_sql_text1 clob;
 input_sql_text2 clob := 'select * from test_utility_est.view4';
 output_sql_text2 clob;
begin
  gms_utility.expand_sql_text(input_sql_text1, output_sql_text1);
  raise info 'output_sql_text1: %', output_sql_text1;
  gms_utility.expand_sql_text(input_sql_text2, output_sql_text2);
  raise info 'output_sql_text2: %', output_sql_text2;
END;
/
INFO:  output_sql_text1: SELECT id, name FROM (SELECT test_1.id, test_1.name FROM test_utility_est.test_1 UNION SELECT test_2.id, test_2.name FROM test_utility_est.test_2) view3
INFO:  output_sql_text2: SELECT id, name FROM (SELECT test_1.id, test_1.name FROM test_utility_est.test_1 UNION SELECT view3.id, view3.name FROM (SELECT test_1.id, test_1.name FROM test_utility_est.test_1 UNION SELECT test_2.id, test_2.name FROM test_utility_est.test_2) view3) view4
declare
 input_sql_text1 clob := 'select * from test_utility_est.view3';
 output_sql_text1 clob;
 input_sql_text2 clob := 'select * from test_utility_est.view4';
 output_sql_text2 clob;
begin
  gms_utility.expand_sql_text(input_sql_text1, output_sql_text1);
  raise info 'output_sql_text1: %', output_sql_text1;
  gms_utility.expand_sql_text(input_sql_text2, output_sql_text2);
  raise info 'output_sql_text2: %', output_sql_text2;
END;
/
INFO:  output_sql_text1: SELECT id, name FROM (SELECT test_1.id, test_1.name FROM test_utility_est.test_1 UNION SELECT test_2.id, test_2.name FROM test_utility_est.test_2) view3
INFO:  output_sql_text2: SELECT id, name FROM (SELECT test_1.id, test_1.name FROM test_utility_est.test_1 UNION SELECT view3.id, view3.name FROM (SELECT test_1.id, test_1.name FROM test_utility_est.test_1 UNION SELECT test_2.id, test_2.name FROM test_utility_est.test_2) view3) view4
-- test not select query, error
declare
    sqlTxt CLOB;
begin
    gms_utility.expand_sql_text('create table test(id int)', sqlTxt);
    raise info 'output_sql_text: %', sqlTxt;
end;
/
ERROR:  Unsupported query type, only support SELECT query
CONTEXT:  PL/pgSQL function gms_utility.expand_sql_text(clob) line 2 at assignment
SQL statement "CALL gms_utility.expand_sql_text('create table test(id int)',sqlTxt)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
    sqlTxt CLOB;
begin
    gms_utility.expand_sql_text('begin', sqlTxt);
    raise info 'output_sql_text: %', sqlTxt;
end;
/
ERROR:  Unsupported query type, only support SELECT query
CONTEXT:  PL/pgSQL function gms_utility.expand_sql_text(clob) line 2 at assignment
SQL statement "CALL gms_utility.expand_sql_text('begin',sqlTxt)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
    sqlTxt CLOB;
begin
    gms_utility.expand_sql_text('update test_1 set name = ''ggboom'' where id = 1', sqlTxt);
    raise info 'output_sql_text: %', sqlTxt;
end;
/
ERROR:  Unsupported query type, only support SELECT query
CONTEXT:  PL/pgSQL function gms_utility.expand_sql_text(clob) line 2 at assignment
SQL statement "CALL gms_utility.expand_sql_text('update test_1 set name = ''ggboom'' where id = 1',sqlTxt)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
    sqlTxt CLOB;
begin
    gms_utility.expand_sql_text('delete from test_1', sqlTxt);
    raise info 'output_sql_text: %', sqlTxt;
end;
/
ERROR:  Unsupported query type, only support SELECT query
CONTEXT:  PL/pgSQL function gms_utility.expand_sql_text(clob) line 2 at assignment
SQL statement "CALL gms_utility.expand_sql_text('delete from test_1',sqlTxt)"
PL/pgSQL function inline_code_block line 3 at SQL statement
-- test not valid query, error
declare
    sqlTxt CLOB;
begin
    gms_utility.expand_sql_text('today is a good day', sqlTxt);
    raise info 'output_sql_text: %', sqlTxt;
end;
/
ERROR:  syntax error at or near "today"
LINE 1: CALL gms_utility.expand_sql_text('today is a good day',sqlTx...
        ^
QUERY:  CALL gms_utility.expand_sql_text('today is a good day',sqlTxt)
CONTEXT:  PL/pgSQL function gms_utility.expand_sql_text(clob) line 2 at assignment
PL/pgSQL function inline_code_block line 3 at SQL statement
create table t1(srvr_id int);
create view expandv as select * from t1;
declare
    vclobin clob := 
'select distinct srvr_id 
from test_utility_est.expandv 
where srvr_id not in 
(select srvr_id 
from test_utility_est.expandv 
minus 
select srvr_id 
from test_utility_est.t1)';
    vclobout clob;
begin
    gms_utility.expand_sql_text(vclobin, vclobout);
    raise info 'output_sql_text: %', vclobout; 
end;
/
INFO:  output_sql_text: SELECT DISTINCT srvr_id FROM (SELECT t1.srvr_id FROM test_utility_est.t1) expandv WHERE NOT (srvr_id IN (SELECT expandv.srvr_id FROM (SELECT t1.srvr_id FROM test_utility_est.t1) expandv EXCEPT SELECT t1.srvr_id FROM test_utility_est.t1))
-- test privileges
create user user01 password 'utility@123';
grant select on test_utility_est.view3 to user01;
set session AUTHORIZATION user01 password 'utility@123';
set search_path to test_utility_est;
declare
 input_sql_text1 clob := 'select * from test_utility_est.view3';
 output_sql_text1 clob;
begin
  gms_utility.expand_sql_text(input_sql_text1, output_sql_text1);
  raise info 'output_sql_text1: %', output_sql_text1;
END;
/
ERROR:  permission denied for schema test_utility_est
LINE 1: CALL gms_utility.expand_sql_text(input_sql_text1,output_sql_...
                      ^
DETAIL:  N/A
QUERY:  CALL gms_utility.expand_sql_text(input_sql_text1,output_sql_text1)
CONTEXT:  PL/pgSQL function gms_utility.expand_sql_text(clob) line 2 at assignment
PL/pgSQL function inline_code_block line 4 at SQL statement
RESET SESSION AUTHORIZATION;
grant usage on schema test_utility_est to user01;
set session AUTHORIZATION user01 password 'utility@123';
set search_path to test_utility_est;
declare
 input_sql_text1 clob := 'select * from test_utility_est.view3';
 output_sql_text1 clob;
begin
  gms_utility.expand_sql_text(input_sql_text1, output_sql_text1);
  raise info 'output_sql_text1: %', output_sql_text1;
END;
/
ERROR:  permission denied for relation view3
DETAIL:  N/A
CONTEXT:  PL/pgSQL function gms_utility.expand_sql_text(clob) line 2 at assignment
SQL statement "CALL gms_utility.expand_sql_text(input_sql_text1,output_sql_text1)"
PL/pgSQL function inline_code_block line 4 at SQL statement
declare
 input_sql_text1 clob := 'select * from test_utility_est.view2';
 output_sql_text1 clob;
begin
  gms_utility.expand_sql_text(input_sql_text1, output_sql_text1);
  raise info 'output_sql_text1: %', output_sql_text1;
END;
/
ERROR:  permission denied for relation view2
DETAIL:  N/A
CONTEXT:  PL/pgSQL function gms_utility.expand_sql_text(clob) line 2 at assignment
SQL statement "CALL gms_utility.expand_sql_text(input_sql_text1,output_sql_text1)"
PL/pgSQL function inline_code_block line 4 at SQL statement
RESET SESSION AUTHORIZATION;
drop view view4;
drop view view3;
drop view view2;
drop view view1;
drop view expandv;
drop materialized view mv_dx;
drop table t1;
drop table if exists t_into;
NOTICE:  table "t_into" does not exist, skipping
drop talbe if exists test_2;
ERROR:  syntax error at or near "talbe"
LINE 1: drop talbe if exists test_2;
             ^
drop talbe if exists test_1;
ERROR:  syntax error at or near "talbe"
LINE 1: drop talbe if exists test_1;
             ^
drop talbe if exists test_dx;
ERROR:  syntax error at or near "talbe"
LINE 1: drop talbe if exists test_dx;
             ^
drop schema test_utility_est;
ERROR:  cannot drop schema test_utility_est because other objects depend on it
DETAIL:  table test_dx depends on schema test_utility_est
table test_1 depends on schema test_utility_est
table test_2 depends on schema test_utility_est
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
---------------------------
-- analyze_schema|database
---------------------------
create user test_utility_analyze password "test_utility_analyze@123";
set search_path to test_utility_analyze;
create table t1 (id int, c2 text);
create unique index t1_id_uidx on t1 using btree(id);
insert into t1 values (generate_series(1, 100), 'aabbcc');
insert into t1 values (generate_series(101, 200), '123dfg');
insert into t1 values (generate_series(201, 300), '人面桃花相映红');
insert into t1 values (generate_series(301, 400), 'fortunate');
insert into t1 values (generate_series(401, 500), 'open@gauss');
insert into t1 values (generate_series(501, 600), '127.0.0.1');
insert into t1 values (generate_series(601, 700), '!@#$!%#!');
insert into t1 values (generate_series(701, 800), '[1,2,3,4]');
insert into t1 values (generate_series(801, 900), '{"name":"张三","age":18}');
insert into t1 values (generate_series(901, 1000), '');
create or replace function batch_insert(count INT)
returns int as $$
declare
	i INT;
	start INT;
begin
	select count(*) into start from t1;
	for i in select generate_series(1, count) loop
		insert into t1 values (start + i, left((pg_catalog.random() * i)::text, 6));
	end loop;

	return count;
end;
$$ language plpgsql;
select batch_insert(50000);
 batch_insert 
--------------
        50000
(1 row)

-- analyze_schema
call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_rows:=10000);
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_rows:=-100);	-- error
ERROR:  invalid value "-100" for "estimate_rows"
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_schema(character varying,character varying,numeric,numeric,character varying) line 2 at PERFORM
call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_percent:=20);
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_percent:=0);
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_percent:=101); -- error
ERROR:  invalid value "101" for "estimate_percent"
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_schema(character varying,character varying,numeric,numeric,character varying) line 2 at PERFORM
call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_rows:=10000, estimate_percent:=101);
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR TABLE');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR ALL INDEXES');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR ALL COLUMNS');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR ALL COLUMNS SIZE 100');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR ALL INDEXED COLUMNS');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR ALL INDEXED COLUMNS SIZE 100');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', estimate_rows:=10000);
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', estimate_percent:=-100);
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', estimate_rows:=10000, estimate_percent:=-100);
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='FOR TABLE');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='FOR ALL INDEXES');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='FOR ALL INDEXED COLUMNS');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='FOR ALL INDEXED COLUMNS SIZE 100');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='FOR ALL COLUMNS');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='FOR ALL COLUMNS SIZE 100');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='FOR TABLE FOR ALL INDEXES');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='FOR TABLE FOR ALL INDEXED COLUMNS');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='FOR TABLE123');	-- error
ERROR:  invalid input value for method_opt
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_schema(character varying,character varying,numeric,numeric,character varying) line 2 at PERFORM
call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='111FOR TABLE');	-- error
ERROR:  unrecognized param value: "111FOR TABLE"
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_schema(character varying,character varying,numeric,numeric,character varying) line 2 at PERFORM
call gms_utility.analyze_schema('test_utility_analyze', 'DELETE');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_schema('test_utility_analyze', 'DELETE', method_opt:='FOR TABLE');	-- error
ERROR:  The Command did not end correctly
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_schema(character varying,character varying,numeric,numeric,character varying) line 2 at PERFORM
DECLARE
    res boolean;
BEGIN
    gms_utility.analyze_schema('SYSTEM','ESTIMATE', NULL, 10);
    EXCEPTION
    WHEN OTHERS THEN
        NULL;
END;
/
--  test analyze database 
call gms_utility.analyze_database('ESTIMATE', estimate_rows:=10000);
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('ESTIMATE', estimate_rows:=-100);	-- error
ERROR:  invalid value "-100" for "estimate_rows"
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema_name,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_database(character varying,numeric,numeric,character varying) line 5 at PERFORM
call gms_utility.analyze_database('ESTIMATE', estimate_percent:=20);
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('ESTIMATE', estimate_percent:=0);
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('ESTIMATE', estimate_percent:=101); -- error
ERROR:  invalid value "101" for "estimate_percent"
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema_name,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_database(character varying,numeric,numeric,character varying) line 5 at PERFORM
call gms_utility.analyze_database('ESTIMATE', estimate_rows:=10000, estimate_percent:=101);
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR TABLE');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR ALL INDEXES');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR ALL COLUMNS');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR ALL COLUMNS SIZE 100');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR ALL INDEXED COLUMNS');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('ESTIMATE', estimate_rows:=10000, estimate_percent:=101, method_opt:='FOR ALL INDEXED COLUMNS SIZE 100');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', estimate_rows:=10000);
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', estimate_percent:=-100);
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', estimate_rows:=10000, estimate_percent:=-100);
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', method_opt:='FOR TABLE');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', method_opt:='FOR ALL INDEXES');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', method_opt:='FOR ALL INDEXED COLUMNS');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', method_opt:='FOR ALL INDEXED COLUMNS SIZE 100');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', method_opt:='FOR ALL COLUMNS');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', method_opt:='FOR ALL COLUMNS SIZE 100');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', method_opt:='FOR TABLE FOR ALL INDEXES');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', method_opt:='FOR TABLE FOR ALL INDEXED COLUMNS');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', method_opt:='FOR TABLE123');	-- error
ERROR:  invalid input value for method_opt
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema_name,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_database(character varying,numeric,numeric,character varying) line 5 at PERFORM
call gms_utility.analyze_database('COMPUTE', method_opt:='111FOR TABLE');	-- error
ERROR:  unrecognized param value: "111FOR TABLE"
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema_name,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_database(character varying,numeric,numeric,character varying) line 5 at PERFORM
call gms_utility.analyze_database('DELETE');
 analyze_database 
------------------
 
(1 row)

call gms_utility.analyze_database('DELETE', method_opt:='FOR TABLE');	-- error
ERROR:  The Command did not end correctly
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema_name,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_database(character varying,numeric,numeric,character varying) line 5 at PERFORM
ALTER INDEX t1_id_uidx UNUSABLE;
call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='FOR ALL INDEXES');
ERROR:  index "t1_id_uidx" is not available
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_schema(character varying,character varying,numeric,numeric,character varying) line 2 at PERFORM
call gms_utility.analyze_database('COMPUTE', method_opt:='FOR ALL INDEXES');
ERROR:  index "t1_id_uidx" is not available
CONTEXT:  SQL statement "CALL gms_utility.analyze_schema_c_fun(schema_name,method,estimate_rows,estimate_percent,method_opt)"
PL/pgSQL function gms_utility.analyze_database(character varying,numeric,numeric,character varying) line 5 at PERFORM
ALTER INDEX t1_id_uidx REBUILD;
call gms_utility.analyze_schema('test_utility_analyze', 'COMPUTE', method_opt:='FOR ALL INDEXES');
 analyze_schema 
----------------
 
(1 row)

call gms_utility.analyze_database('COMPUTE', method_opt:='FOR ALL INDEXES');
 analyze_database 
------------------
 
(1 row)

drop table t1 cascade;
drop function batch_insert;
reset search_path;
drop user test_utility_analyze cascade;
---------------------------
-- canonicalize
---------------------------
create schema test_utility_canonicalize;
set search_path to test_utility_canonicalize;
-- canonicalize
declare
    canon_name varchar2(100);
begin
    gms_utility.canonicalize('uwclass.test', canon_name, 16);
    raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: "UWCLASS"."TEST"
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.rooy.nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: "KOLL"."ROOY"."NUUOP"."A"
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.rooy.nuuop.a', canon_name);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  function "canonicalize" with 2 parameters doesn't exist 
CONTEXT:  SQL statement "CALL gms_utility.canonicalize('koll.rooy.nuuop.a',canon_name)"
PL/pgSQL function inline_code_block line 3 at SQL statement
-- empty、space
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize(NULL, canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- NULL
/
INFO:  canon_name: <NULL>
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: <NULL>
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('""', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Invalid parameter value """" with zero length
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('""',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('     ', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: 
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('''''', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end; -- error
/
ERROR:  Invalid parameter value "''" with special character
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('''''',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('"''''"', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: ''
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.ro oy.nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end; -- error
/
ERROR:  Invalid parameter value "koll.ro oy.nuuop.a"
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.ro oy.nuuop.a',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll."ro oy".nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: "KOLL"."ro oy"."NUUOP"."A"
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('    .abcd', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Invalid parameter value "    .abcd" with special words
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('    .abcd',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll..nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Invalid parameter value "koll..nuuop.a" with special words
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll..nuuop.a',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll."".nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Invalid parameter value "koll."".nuuop.a" with zero length
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll."".nuuop.a',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: KOLL
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('"koll"', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: koll
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('   "  koll.rooy"  .nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: "  koll.rooy"."NUUOP"."A"
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.rooy.nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: "KOLL"."ROOY"."NUUOP"."A"
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('"~!#@@#$%)(#@(!@))<>?/*-+".nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: "~!#@@#$%)(#@(!@))<>?/*-+"."NUUOP"."A"
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.rooy#_$nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: "KOLL"."ROOY#_$NUUOP"."A"
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.ro,oy.nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end; -- error
/
ERROR:  Invalid parameter value "koll.ro,oy.nuuop.a" with special character
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.ro,oy.nuuop.a',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll."rooy"  abc.nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;  	-- error
/
ERROR:  Invalid parameter value "koll."rooy"  abc.nuuop.a" after quotation
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll."rooy"  abc.nuuop.a',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.rooy.nuuop.', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Invalid parameter value "koll.rooy.nuuop."
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.rooy.nuuop.',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.rooy.nu"uo"p', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Invalid parameter value "koll.rooy.nu"uo"p" before quotation
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.rooy.nu"uo"p',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.rooy."nu"u"o"p', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Invalid parameter value "koll.rooy."nu"u"o"p" after quotation
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.rooy."nu"u"o"p',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll."rooy"."nuuop.', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Invalid parameter value "koll."rooy"."nuuop." with quotation not closed
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll."rooy"."nuuop.',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
-- identy
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.123rooy.nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Invalid parameter value "koll.123rooy.nuuop.a" with special words
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.123rooy.nuuop.a',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll._rooy.nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- ok for og, error for A
/
INFO:  canon_name: "KOLL"."_ROOY"."NUUOP"."A"
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.#rooy.nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Invalid parameter value "koll.#rooy.nuuop.a" with special words
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.#rooy.nuuop.a',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.$rooy.nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Invalid parameter value "koll.$rooy.nuuop.a" with special words
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.$rooy.nuuop.a',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll."_rooy".nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: "KOLL"."_rooy"."NUUOP"."A"
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('table', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: TABLE
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.rooy.table.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end; -- error
/
ERROR:  Invalid parameter value "koll.rooy.table.a" with special words
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.rooy.table.a',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('column', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: COLUMN
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.column.nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end; -- error
/
ERROR:  Invalid parameter value "koll.column.nuuop.a" with special words
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.column.nuuop.a',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
-- test indentifier overlength; og >= 64, A >= 128
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.DoYouThinkCausalUnderstandingIsADefiningCharacteristicOfHumanCognition.nuuop.a', canon_name, 100);
	raise info 'canon_name: %', canon_name;
end;
/
ERROR:  identifier too long, max length is 63
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.DoYouThinkCausalUnderstandingIsADefiningCharacteristicOfHumanCognition.nuuop.a',canon_name,100)"
PL/pgSQL function inline_code_block line 3 at SQL statement
-- param canon_len
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.rooy.nuuop.a', canon_name, -10);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  Input parameter "canon_len" value "-10" should be greater than or equal to 0 
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize('koll.rooy.nuuop.a',canon_name,-10)"
PL/pgSQL function inline_code_block line 3 at SQL statement
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.rooy.nuuop.a', canon_name, 0);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: 
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('koll.rooy.nuuop.a', canon_name, 10);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: "KOLL"."RO
declare
	canon_name varchar2(100);
begin
	gms_utility.canonicalize('开车.rooy.nuuop.a', canon_name, 10);
	raise info 'canon_name: %', canon_name;
end;
/
INFO:  canon_name: "开车"."
declare
	canon_name varchar2(10);
begin
	gms_utility.canonicalize('koll.rooy.nuuop.a', canon_name, 20);
	raise info 'canon_name: %', canon_name;
end;	-- error
/
ERROR:  value too long for type character varying(10)
CONTEXT:  PL/pgSQL function inline_code_block line 3 at SQL statement
declare
   v_input_name   varchar2(255) := 'agdbchwnnw_test_adhsd_123_dbscbswcbswcbswjbc$2384243758475_fhdkj';
   v_canon_name   varchar2(255);
   v_canon_len    binary_integer := 200;
begin
   gms_utility.canonicalize(
      name        => v_input_name,
      canon_name  => v_canon_name,
      canon_len   => v_canon_len
   );
   raise info 'original name: %', v_input_name;
   raise info 'original name length: %', length(v_input_name);
   raise info 'canonicalized name: %', v_canon_name;
   raise info 'canonicalized name length: %', length(v_canon_name);
end; -- error
/
ERROR:  identifier too long, max length is 63
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize(name        => v_input_name,canon_name=>v_canon_name,canon_len   => v_canon_len
   )"
PL/pgSQL function inline_code_block line 5 at SQL statement
declare
   v_input_name   varchar2(255) := 'abc.test,c.f';
   v_canon_name   varchar2(255);
   v_canon_len    binary_integer := 100;
begin
   gms_utility.canonicalize(
      name        => v_input_name,
      canon_name  => v_canon_name,
      canon_len   => v_canon_len
   );
   raise info 'original name: %', v_input_name;
   raise info 'canonicalized name: %', v_canon_name;
   raise info 'canonicalized name length: %', length(v_canon_name);
end; -- error
/
ERROR:  Invalid parameter value "abc.test,c.f" with special character
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize(name        => v_input_name,canon_name=>v_canon_name,canon_len   => v_canon_len
   )"
PL/pgSQL function inline_code_block line 5 at SQL statement
declare
   v_input_name   varchar2(255) := '123';
   v_canon_name   varchar2(255);
   v_canon_len    binary_integer := 255;
begin
  gms_utility.canonicalize(
      name        => v_input_name,
      canon_name  => v_canon_name,
      canon_len   => v_canon_len
   );

  raise info 'original name: %', v_input_name;
  raise info 'canonicalized name: %', v_canon_name;
  raise info 'canonicalized name length: %', length(v_canon_name);
end;
/
INFO:  original name: 123
INFO:  canonicalized name: 123
INFO:  canonicalized name length: 3
declare
   v_input_name   varchar2(255) := 'exam  ple';
   v_canon_name   varchar2(255);
   v_canon_len    binary_integer := 255;
begin
  gms_utility.canonicalize(
      name        => v_input_name,
      canon_name  => v_canon_name,
      canon_len   => v_canon_len
   );
  raise info 'original name: %', v_input_name;
  raise info 'canonicalized name: %', v_canon_name;
  raise info 'canonicalized name length: %', length(v_canon_name);
end;
/
ERROR:  Invalid parameter value "exam  ple"
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize(name        => v_input_name,canon_name=>v_canon_name,canon_len   => v_canon_len
   )"
PL/pgSQL function inline_code_block line 5 at SQL statement
declare
   v_input_name   varchar2(255) := 'exa mple.tab_na me';
   v_canon_name   varchar2(255);
   v_canon_len    binary_integer := 255;
begin
   gms_utility.canonicalize(
      name        => v_input_name,
      canon_name  => v_canon_name,
      canon_len   => v_canon_len
   );
   raise info 'original name: %', v_input_name;
   raise info 'canonicalized name: %', v_canon_name;
   raise info 'canonicalized name length: %', length(v_canon_name);
end;
/
ERROR:  Invalid parameter value "exa mple.tab_na me"
CONTEXT:  PL/pgSQL function gms_utility.canonicalize(character varying,integer) line 5 at assignment
SQL statement "CALL gms_utility.canonicalize(name        => v_input_name,canon_name=>v_canon_name,canon_len   => v_canon_len
   )"
PL/pgSQL function inline_code_block line 5 at SQL statement
drop schema test_utility_canonicalize;
---------------------------
-- compile schema
---------------------------
create schema test_utility_compile;
set search_path to test_utility_compile;
create table classes (  
    class_id int primary key,  
    class_name varchar(50) not null  
)
with (orientation=row, compression=no);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "classes_pkey" for table "classes"
  
create table students (  
    student_id int primary key,  
    class_id int,  
    student_name varchar(50) not null
)
with (orientation=row, compression=no);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "students_pkey" for table "students"
  
create table studentscores (  
    score_id int primary key,  
    student_id int,  
    subject varchar(50),  
    score int
)
with (orientation=row, compression=no);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "studentscores_pkey" for table "studentscores"
create or replace procedure insertclass(in classname varchar(50))
as
	ct int;
begin
	select count(class_id) into ct from classes;
    insert into classes values (ct + 1, classname);
end;
/
  
create or replace procedure insertstudent(in classname varchar(50), in studentname varchar(50))
as
	classid int;
	ct int;
begin  
    select class_id into classid from classes where class_name = classname;
	select count(student_id) into ct from students;
    insert into students values (ct + 1, classid, studentname);
end;
/
create or replace function insertscore(studentid int, subject varchar(50), score int)  
returns int
as $$
declare
	ct int;
begin
	select count(score_id) into ct from studentscores;
    insert into studentscores values (ct + 1, studentid, subject, score);
    return ct + 1;  
end;
$$ language plpgsql;
create or replace function getrank(score int)
returns text
as $$
declare
    rk text;
begin
    if score = 100 then
        rk := 'perfect';
    elsif score >= 80 then
        rk := 'nice';
    elsif score >= 60 then
        rk := 'ordinary';
    elsif score >= 0 then
        rk := 'poor';
    else
        raise notice 'error input';
    end if;

    return rk;
end;
$$ language plpgsql;
call insertclass('class a');  
 insertclass 
-------------
 
(1 row)

call insertclass('class b');  
 insertclass 
-------------
 
(1 row)

  
call insertstudent('class a', 'alice');  
 insertstudent 
---------------
 
(1 row)

call insertstudent('class a', 'bob');  
 insertstudent 
---------------
 
(1 row)

call insertstudent('class b', 'charlie');  
 insertstudent 
---------------
 
(1 row)

call insertstudent('class b', 'rose');
 insertstudent 
---------------
 
(1 row)

call insertstudent('class b', 'jack');
 insertstudent 
---------------
 
(1 row)

  
select insertscore(1, 'math', 90);  
 insertscore 
-------------
           1
(1 row)

select insertscore(1, 'science', 85);  
 insertscore 
-------------
           2
(1 row)

select insertscore(2, 'math', 95);  
 insertscore 
-------------
           3
(1 row)

select insertscore(2, 'science', 88);  
 insertscore 
-------------
           4
(1 row)

select insertscore(3, 'math', 78);  
 insertscore 
-------------
           5
(1 row)

select insertscore(3, 'science', 82);
 insertscore 
-------------
           6
(1 row)

select insertscore(4, 'math', 100);  
 insertscore 
-------------
           7
(1 row)

select insertscore(4, 'science', 66);
 insertscore 
-------------
           8
(1 row)

select insertscore(5, 'math', 57);  
 insertscore 
-------------
           9
(1 row)

select insertscore(5, 'science', 68);
 insertscore 
-------------
          10
(1 row)

create view stud_class as select s.student_name, c.class_name from students s join classes c on s.class_id = c.class_id;
create view stud_score as select b.student_name, a.subject, a.score, getrank(a.score) from studentscores a join students b on a.student_id = b.student_id;
create table t_pkg (c1 text);
create package p_batch as
	procedure insertpkg(txt text);
	function batchinsert(num int) return int;
end p_batch;
/
create package body p_batch as
    procedure insertpkg(txt text)
    as
    begin
        insert into t_pkg values (txt);
    end;

    function batchinsert(num int)
    return int
    is
        start int := 0;
        i int := 0;
    begin
        select count(*) into start from t_pkg;
        for i in select generate_series(1, num) loop
            insert into t1 values (start + i, left((pg_catalog.random() * i)::text, 6));
        end loop;

        return i;
    end;
end p_batch;
/
call gms_utility.compile_schema('test_utility_compile');
 compile_schema 
----------------
 
(1 row)

call gms_utility.compile_schema('test_utility_compile', false);
 compile_schema 
----------------
 
(1 row)

call gms_utility.compile_schema('test_utility_compile', true, false);
 compile_schema 
----------------
 
(1 row)

call gms_utility.compile_schema(); -- error
ERROR:  function "compile_schema" with 0 parameters doesn't exist 
call gms_utility.compile_schema(1); -- error
ERROR:  schema "1" does not exists
CONTEXT:  SQL statement "CALL gms_utility.compile_schema_c_func(schema,compile_all,reuse_settings)"
PL/pgSQL function gms_utility.compile_schema(character varying,boolean,boolean) line 2 at PERFORM
call gms_utility.compile_schema('no_schema'); -- error
ERROR:  schema "no_schema" does not exists
CONTEXT:  SQL statement "CALL gms_utility.compile_schema_c_func(schema,compile_all,reuse_settings)"
PL/pgSQL function gms_utility.compile_schema(character varying,boolean,boolean) line 2 at PERFORM
create or replace function getrank(score int)
returns text
as $$
declare
    rk text;
begin
    if score = 100 then
        rk := 'perfect';
    elsif score >= 80 then
        rk := 'nice';
    elsif score >= 60 then
        rk := 'ordinary';
    elsif score >= 0 then
        rk := 'poor';
    else
        rk := 'error';
    end if;

    return rk;
end;
$$ language plpgsql;
call gms_utility.compile_schema('test_utility_compile');
 compile_schema 
----------------
 
(1 row)

drop package body p_batch;
drop package p_batch;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to function test_utility_compile.insertpkg(text)
drop cascades to function test_utility_compile.batchinsert(integer)
drop table t_pkg;
drop view stud_score;
drop view stud_class;
drop function getrank;
drop function insertscore;
drop procedure insertstudent;
drop procedure insertclass;
drop table studentscores;
drop table students;
drop table classes;
-- test invalid object compile
set behavior_compat_options = 'plpgsql_dependency';
create type s_type as (
    id integer,
    name varchar,
    addr text
);
create or replace procedure type_alter(a s_type)
is
begin    
    raise info 'call a: %', a;
end;
/
select valid from pg_object where object_type='P' and object_oid in (select oid from pg_proc where propackageid = 0 and proname='type_alter' and pronamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
 t
(1 row)

alter type s_type add attribute a int;
select valid from pg_object where object_type='P' and object_oid in (select oid from pg_proc where propackageid = 0 and proname='type_alter' and pronamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
 f
(1 row)

call gms_utility.compile_schema('test_utility_compile', false);
 compile_schema 
----------------
 
(1 row)

select valid from pg_object where object_type='P' and object_oid in (select oid from pg_proc where propackageid = 0 and proname='type_alter' and pronamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
 t
(1 row)

create table stu(sno int, name varchar, sex varchar, cno int);
create type r1 as (a int, c stu%rowtype);
create or replace package pkg
is    
    procedure proc1(p_in r1);
end pkg;
/
create or replace package body pkg
is
declare
    v1 r1;
    v2 stu%rowtype;
    procedure proc1(p_in r1) as
    begin        
    raise info 'call p_in: %', p_in;
    end;
end pkg;
/
call pkg.proc1((1,(1,'zhang','m',1)));
INFO:  call p_in: (1,"(1,zhang,m,1)")
 proc1 
-------
 
(1 row)

select valid from pg_object where object_type='B' and object_oid in (select oid from gs_package where pkgname='pkg' and pkgnamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
 t
(1 row)

alter table stu add column b int;
select valid from pg_object where object_type='B' and object_oid in (select oid from gs_package where pkgname='pkg' and pkgnamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
 f
(1 row)

call gms_utility.compile_schema('test_utility_compile', false);
 compile_schema 
----------------
 
(1 row)

select valid from pg_object where object_type='B' and object_oid in (select oid from gs_package where pkgname='pkg' and pkgnamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
 t
(1 row)

create view v_stu as select * from stu;
select * from v_stu;
 sno | name | sex | cno | b 
-----+------+-----+-----+---
(0 rows)

select valid from pg_object where object_type='v' and object_oid in (select oid from pg_class where relname='v_stu' and relkind='v' and relnamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
 t
(1 row)

alter table stu drop column b;
select valid from pg_object where object_type='v' and object_oid in (select oid from pg_class where relname='v_stu' and relkind='v' and relnamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
 f
(1 row)

call gms_utility.compile_schema('test_utility_compile', false);
WARNING:  Compile view "v_stu" failed
CONTEXT:  SQL statement "CALL gms_utility.compile_schema_c_func(schema,compile_all,reuse_settings)"
PL/pgSQL function gms_utility.compile_schema(character varying,boolean,boolean) line 2 at PERFORM
 compile_schema 
----------------
 
(1 row)

select valid from pg_object where object_type='v' and object_oid in (select oid from pg_class where relname='v_stu' and relkind='v' and relnamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
 f
(1 row)

select * from v_stu;
ERROR:  The view v_stu is invalid, please make it valid before operation.
HINT:  Please re-add missing table fields.
alter table stu add column b int;
select valid from pg_object where object_type='v' and object_oid in (select oid from pg_class where relname='v_stu' and relkind='v' and relnamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
 f
(1 row)

call gms_utility.compile_schema('test_utility_compile', false);
 compile_schema 
----------------
 
(1 row)

select valid from pg_object where object_type='v' and object_oid in (select oid from pg_class where relname='v_stu' and relkind='v' and relnamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
 t
(1 row)

select * from v_stu;
 sno | name | sex | cno | b 
-----+------+-----+-----+---
(0 rows)

drop view v_stu;
drop package body pkg;
drop package pkg;
NOTICE:  drop cascades to function test_utility_compile.proc1(r1)
drop type r1;
drop table stu;
drop procedure type_alter;
-- test procedure compile error
set behavior_compat_options = 'plpgsql_dependency';
create or replace procedure proc_err(p_in s_type) as
begin
    raise info 'call p_in: %', p_in;
end;
/
drop type s_type;
select valid from pg_object where object_type='p' and object_oid in (select oid from pg_proc where propackageid = 0 and proname='proc_err' and pronamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
(0 rows)

call gms_utility.compile_schema('test_utility_compile', false);
WARNING:  "proc_err" header is undefined, you can try to recreate.
CONTEXT:  SQL statement "CALL gms_utility.compile_schema_c_func(schema,compile_all,reuse_settings)"
PL/pgSQL function gms_utility.compile_schema(character varying,boolean,boolean) line 2 at PERFORM
 compile_schema 
----------------
 
(1 row)

select valid from pg_object where object_type='p' and object_oid in (select oid from pg_proc where propackageid = 0 and proname='proc_err' and pronamespace = (select oid from pg_namespace where nspname = 'test_utility_compile'));
 valid 
-------
(0 rows)

drop procedure proc_err;
drop schema test_utility_compile cascade;
---------------------------
-- name tokenize
---------------------------
create schema test_utility_tokenize;
set search_path to test_utility_tokenize;
create or replace procedure test_name_tokenize(name in varchar2)
as
  a varchar2(100);
  b varchar2(100);
  c varchar2(100);
  dblink varchar2(100);
  nextpos int;
begin
  gms_utility.name_tokenize(name, a, b, c, dblink, nextpos);
  raise info 'a: [%], b: [%], c: [%], dblink: [%], nextpos: %', a, b, c, dblink, nextpos;
end;
/
call test_name_tokenize('peer.lokppe.vuumee@ookeyy');
INFO:  a: [PEER], b: [LOKPPE], c: [VUUMEE], dblink: [OOKEYY], nextpos: 25
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize(NULL); -- error
ERROR:  Invalid input value
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize(''); -- error
ERROR:  Invalid input value
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('""'); -- error
ERROR:  Invalid input value """" with zero length
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('  .  '); -- error
ERROR:  Invalid input value "  .  " with special words
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('"  .  "');
INFO:  a: [  .  ], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 7
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.   lokppe.vuumee@ookeyy');
INFO:  a: [PEER], b: [LOKPPE], c: [VUUMEE], dblink: [OOKEYY], nextpos: 28
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer."   lokppe.vuumee"@ookeyy');
INFO:  a: [PEER], b: [   lokppe.vuumee], c: [<NULL>], dblink: [OOKEYY], nextpos: 30
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('sco  ot');  -- SCO 5
INFO:  a: [SCO], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 5
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('"sco  ot"');
INFO:  a: [sco  ot], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 9
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('sco  ot.foook'); -- SCO 5
INFO:  a: [SCO], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 5
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('"sco  ot".fook');
INFO:  a: [sco  ot], b: [FOOK], c: [<NULL>], dblink: [<NULL>], nextpos: 14
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('"sco  ot"   .fook');
INFO:  a: [sco  ot], b: [FOOK], c: [<NULL>], dblink: [<NULL>], nextpos: 17
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('"sco  ot"   abcd.fook'); -- sco  ot 12
INFO:  a: [sco  ot], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 12
 test_name_tokenize 
--------------------
 
(1 row)

-- test support special char
call test_name_tokenize('peer._lokppe.vuumee@ookeyy'); -- ok for og, error for A
INFO:  a: [PEER], b: [_LOKPPE], c: [VUUMEE], dblink: [OOKEYY], nextpos: 26
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokp_pe.vuumee@ookeyy');
INFO:  a: [PEER], b: [LOKP_PE], c: [VUUMEE], dblink: [OOKEYY], nextpos: 26
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.$lokppe.vuumee@ookeyy'); -- error
ERROR:  Invalid input value "peer.$lokppe.vuumee@ookeyy" with special words
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer.lokp$pe.vuumee@ookeyy');
INFO:  a: [PEER], b: [LOKP$PE], c: [VUUMEE], dblink: [OOKEYY], nextpos: 26
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokp233pe.vuumee@ookeyy');
INFO:  a: [PEER], b: [LOKP233PE], c: [VUUMEE], dblink: [OOKEYY], nextpos: 28
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.233lokppe.vuumee@ookeyy');
INFO:  a: [PEER], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 4
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.-lokppe.vuumee@ookeyy'); -- error
ERROR:  Invalid input value "eer.-lokppe.vuumee@ookeyy"
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer."-lokppe".vuumee@ookeyy');
INFO:  a: [PEER], b: [-lokppe], c: [VUUMEE], dblink: [OOKEYY], nextpos: 28
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokp-pe.vuumee@ookeyy'); -- 9
INFO:  a: [PEER], b: [LOKP], c: [<NULL>], dblink: [<NULL>], nextpos: 9
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokp=pe.vuumee@ookeyy'); -- 9
INFO:  a: [PEER], b: [LOKP], c: [<NULL>], dblink: [<NULL>], nextpos: 9
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.=lokppe.vuumee@ookeyy'); -- error
ERROR:  Invalid input value "eer.=lokppe.vuumee@ookeyy"
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer.lokp`pe.vuumee@ookeyy'); -- error
ERROR:  Invalid input value "peer.lokp`pe.vuumee@ookeyy" with special character
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer.lokp~pe.vuumee@ookeyy'); -- error
ERROR:  Invalid input value "peer.lokp~pe.vuumee@ookeyy" with special character
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer.lokp%pe.vuumee@ookeyy'); -- error
ERROR:  Invalid input value "peer.lokp%pe.vuumee@ookeyy" with special character
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('123_abc'); -- error
ERROR:  Invalid Input value "123_abc"
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('"123_abc"');
INFO:  a: [123_abc], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 9
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('123'); -- error
ERROR:  Invalid Input value "123"
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('"123"');
INFO:  a: [123], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 5
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize(''''''); -- error
ERROR:  Invalid input value "''" with special character
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('"''''"');
INFO:  a: [''], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 4
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize(''''); -- error
ERROR:  Invalid input value "'" with special character
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('"''"'); 
INFO:  a: ['], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 3
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer,lokppe,vuumee@ookeyy'); 
INFO:  a: [PEER], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 4
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokppe,vuumee@ookeyy');
INFO:  a: [PEER], b: [LOKPPE], c: [<NULL>], dblink: [<NULL>], nextpos: 11
 test_name_tokenize 
--------------------
 
(1 row)

-- test keyword
call test_name_tokenize('peer.table.vuumee@ookeyy'); -- error
ERROR:  Invalid input value "peer.table.vuumee@ookeyy" with special words
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer."table".vuumee@ookeyy');
INFO:  a: [PEER], b: [table], c: [VUUMEE], dblink: [OOKEYY], nextpos: 26
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.column.vuumee@ookeyy'); -- error
ERROR:  Invalid input value "peer.column.vuumee@ookeyy" with special words
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer."column".vuumee@ookeyy');
INFO:  a: [PEER], b: [column], c: [VUUMEE], dblink: [OOKEYY], nextpos: 27
 test_name_tokenize 
--------------------
 
(1 row)

-- test @
call test_name_tokenize('peer.lokppe.vuumee@'); -- error
ERROR:  Invalid input value "peer.lokppe.vuumee@" with special words
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer.lokppe.vuumee@_ookeyy'); -- ok for og, error for A
INFO:  a: [PEER], b: [LOKPPE], c: [VUUMEE], dblink: [_OOKEYY], nextpos: 26
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokppe.vuumee@"_ookeyy"');
INFO:  a: [PEER], b: [LOKPPE], c: [VUUMEE], dblink: [_ookeyy], nextpos: 28
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokppe.vuumee@$ookeyy');
ERROR:  Invalid input value "peer.lokppe.vuumee@$ookeyy" with special words
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer.lokppe.vuumee@"$ookeyy"');
INFO:  a: [PEER], b: [LOKPPE], c: [VUUMEE], dblink: [$ookeyy], nextpos: 28
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokppe.vuumee@123ookeyy'); -- error
ERROR:  Invalid dblink value "peer.lokppe.vuumee@123ookeyy"
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer.lokppe.vuumee@ookeyy.zk');
INFO:  a: [PEER], b: [LOKPPE], c: [VUUMEE], dblink: [OOKEYY.ZK], nextpos: 28
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('@vuumee'); -- error
ERROR:  Invalid input value "@vuumee" with special words
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer.lokppe.vuumee@ook=eyy');
INFO:  a: [PEER], b: [LOKPPE], c: [VUUMEE], dblink: [OOK], nextpos: 22
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokppe.vuumee@=ookeyy'); -- error
ERROR:  Invalid input value "eer.lokppe.vuumee@=ookeyy" with special words
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('peer.lokppe.vuumee@ook eyy');
INFO:  a: [PEER], b: [LOKPPE], c: [VUUMEE], dblink: [OOK], nextpos: 23
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokppe.vuumee@ook%eyy'); -- error
ERROR:  Invalid input value "peer.lokppe.vuumee@ook%eyy" with special character
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
call test_name_tokenize('"scott@db1"');
INFO:  a: [scott@db1], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 11
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('"scott.@db1"');
INFO:  a: [scott.@db1], b: [<NULL>], c: [<NULL>], dblink: [<NULL>], nextpos: 12
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer."@test"."@name"@dblink');
INFO:  a: [PEER], b: [@test], c: [@name], dblink: [DBLINK], nextpos: 27
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('test."name#!^&*()-=+[]{}/|:<>@"scott@ins');
INFO:  a: [TEST], b: [name#!^&*()-=+[]{}/|:<>@], c: [<NULL>], dblink: [<NULL>], nextpos: 31
 test_name_tokenize 
--------------------
 
(1 row)

-- test double quote
call test_name_tokenize('peer.lokppe.vuumee"@ookeyy"');
INFO:  a: [PEER], b: [LOKPPE], c: [VUUMEE], dblink: [<NULL>], nextpos: 18
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokppe.vu"ume"e@ookeyy');
INFO:  a: [PEER], b: [LOKPPE], c: [VU], dblink: [<NULL>], nextpos: 14
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokppe."vu"ume"e@ookeyy');
INFO:  a: [PEER], b: [LOKPPE], c: [vu], dblink: [<NULL>], nextpos: 16
 test_name_tokenize 
--------------------
 
(1 row)

call test_name_tokenize('peer.lokppe.vuumee.aking@ookeyy'); -- error
ERROR:  Invalid input value "peer.lokppe.vuumee.aking@ookeyy"
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
-- test idnetifier overlength. og >= 64, A >= 128
call test_name_tokenize('peer.DoYouThinkCausalUnderstandingIsADefiningCharacteristicOfHumanCognition.vuumee@ookeyy'); -- error
ERROR:  identifier too long, max length is 63
CONTEXT:  PL/pgSQL function gms_utility.name_tokenize(character varying) line 4 at assignment
SQL statement "CALL gms_utility.name_tokenize(name,a,b,c,dblink,nextpos)"
PL/pgSQL function test_name_tokenize(character varying) line 7 at SQL statement
drop procedure test_name_tokenize;
drop schema test_utility_tokenize;
---------------------------
-- name resolve
---------------------------
reset search_path;
-- prepare data
CREATE TABLE public.t_resolve (c1 NUMBER, c2 VARCHAR2(100));
CREATE UNIQUE INDEX IF NOT EXISTS public.t_resolve_c1_udx ON public.t_resolve(c1);
CREATE TABLE public.t_log (c1 NUMBER, c2 TIMESTAMP);
CREATE SEQUENCE IF NOT EXISTS public.t_seq
    INCREMENT BY 1
    NOMINVALUE
    NOMAXVALUE
    START WITH 1
    NOCYCLE;
SELECT public.t_seq.NEXTVAL;
 nextval 
---------
       1
(1 row)

CREATE OR REPLACE FUNCTION public.add_numbers (  
    p_num1 IN INT,  
    p_num2 IN INT  
) RETURN NUMBER IS  
    v_result INT;  
BEGIN  
    v_result := p_num1 + p_num2;  
    RETURN v_result;  
END;  
/
CREATE OR REPLACE PROCEDURE public.insert_val(name VARCHAR2(100)) IS 
	id INT := 0;
BEGIN 
	SELECT public.t_seq.NEXTVAL INTO id;
	INSERT INTO public.t_resolve VALUES (id, name);
END;
/
CREATE OR REPLACE FUNCTION public.tg_log() RETURNS TRIGGER AS
$$
BEGIN
    INSERT INTO public.t_log VALUES (NEW.c1, SYSDATE);
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;
CREATE TRIGGER log_resolve_after_insert
AFTER INSERT ON public.t_resolve 
FOR EACH ROW 
EXECUTE PROCEDURE public.tg_log();
CREATE OR REPLACE PACKAGE public.t_pkg IS
    FUNCTION multi_number(num1 IN INT, num2 IN INT) RETURN INT;
    PROCEDURE delete_val(id IN INT);
END t_pkg;
/
CREATE OR REPLACE PACKAGE BODY public.t_pkg IS
    FUNCTION multi_number(num1 IN INT, num2 IN INT) RETURN INT IS
        v_res INT;
    BEGIN
        v_res = num1 * num2;
        return v_res;
    END multi_number;

    PROCEDURE delete_val(id IN INT) AS
    BEGIN
        DELETE FROM t_resolve WHERE c1 = id;
    END delete_val;
END t_pkg;
/
CREATE TYPE public.t_typ AS (t1 INT, t2 TEXT);
CREATE OR REPLACE SYNONYM public.syn_tbl FOR t_resolve;
CREATE OR REPLACE SYNONYM public.syn_idx FOR t_resolve_c1_udx;
CREATE OR REPLACE SYNONYM public.syn_seq FOR t_seq;
CREATE OR REPLACE SYNONYM public.syn_fun FOR add_numbers;
CREATE OR REPLACE SYNONYM public.syn_pro FOR insert_val;
CREATE OR REPLACE SYNONYM public.syn_tg FOR log_resolve_after_insert;
CREATE OR REPLACE SYNONYM public.syn_pkg FOR t_pkg;
CREATE OR REPLACE SYNONYM public.syn_typ FOR t_typ;
create or replace procedure test_name_resolve(input in varchar2, context in numeric)
as
  schema varchar2(100);
  part1 varchar2(100);
  part2 varchar2(100);
  dblink varchar2(100);
  part1_type number;
  object_number number;
begin
  gms_utility.name_resolve(input, context, schema, part1, part2, dblink, part1_type, object_number);
  raise info 'schema: [%], part1: [%], part2: [%], dblink: [%], part1_type: %, object_number: %', schema, part1, part2, dblink, part1_type, object_number;
end;
/
-- test table
call test_name_resolve('public.t_resolve', 0);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE], part2: [<NULL>], dblink: [<NULL>], part1_type: 2, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.t_resolve', NULL);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE], part2: [<NULL>], dblink: [<NULL>], part1_type: 2, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('t_resolve', 0);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE], part2: [<NULL>], dblink: [<NULL>], part1_type: 2, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('t_resolve', NULL);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE], part2: [<NULL>], dblink: [<NULL>], part1_type: 2, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.syn_tbl', 0);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE], part2: [<NULL>], dblink: [<NULL>], part1_type: 2, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.syn_tbl', NULL);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE], part2: [<NULL>], dblink: [<NULL>], part1_type: 2, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('syn_tbl', 0);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE], part2: [<NULL>], dblink: [<NULL>], part1_type: 2, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('syn_tbl', NULL);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE], part2: [<NULL>], dblink: [<NULL>], part1_type: 2, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.t_resolve', 2);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE], part2: [<NULL>], dblink: [<NULL>], part1_type: 6, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.t_resolve', 7);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE], part2: [<NULL>], dblink: [<NULL>], part1_type: 13, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.t_resolve', 9); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
-- test PL/SQL
call test_name_resolve('public.add_numbers', 1);
--?INFO:  schema: [PUBLIC], part1: [<NULL>], part2: [ADD_NUMBERS], dblink: [<NULL>], part1_type: 8, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('add_numbers', 1);
--?INFO:  schema: [PUBLIC], part1: [<NULL>], part2: [ADD_NUMBERS], dblink: [<NULL>], part1_type: 8, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.syn_fun', 1);
--?INFO:  schema: [PUBLIC], part1: [<NULL>], part2: [ADD_NUMBERS], dblink: [<NULL>], part1_type: 8, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('syn_fun', 1);
--?INFO:  schema: [PUBLIC], part1: [<NULL>], part2: [ADD_NUMBERS], dblink: [<NULL>], part1_type: 8, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.insert_val', 1);
--?INFO:  schema: [PUBLIC], part1: [<NULL>], part2: [INSERT_VAL], dblink: [<NULL>], part1_type: 7, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('insert_val', 1);
--?INFO:  schema: [PUBLIC], part1: [<NULL>], part2: [INSERT_VAL], dblink: [<NULL>], part1_type: 7, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.syn_pro', 1);
--?INFO:  schema: [PUBLIC], part1: [<NULL>], part2: [INSERT_VAL], dblink: [<NULL>], part1_type: 7, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('syn_pro', 1);
--?INFO:  schema: [PUBLIC], part1: [<NULL>], part2: [INSERT_VAL], dblink: [<NULL>], part1_type: 7, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

-- test package
call test_name_resolve('public.t_pkg.multi_number', 1);
--?INFO:  schema: [PUBLIC], part1: [T_PKG], part2: [MULTI_NUMBER], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.t_pkg.delete_val', 1);
--?INFO:  schema: [PUBLIC], part1: [T_PKG], part2: [DELETE_VAL], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.t_pkg.qwer', 1);
--?INFO:  schema: [PUBLIC], part1: [T_PKG], part2: [QWER], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('t_pkg.multi_number', 1);
--?INFO:  schema: [public], part1: [T_PKG], part2: [MULTI_NUMBER], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('t_pkg.delete_val', 1);
--?INFO:  schema: [public], part1: [T_PKG], part2: [DELETE_VAL], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('t_pkg.qwer', 1);
--?INFO:  schema: [public], part1: [T_PKG], part2: [QWER], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.syn_pkg.multi_number', 1);
--?INFO:  schema: [PUBLIC], part1: [T_PKG], part2: [MULTI_NUMBER], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.syn_pkg.delete_var', 1);
--?INFO:  schema: [PUBLIC], part1: [T_PKG], part2: [DELETE_VAR], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.syn_pkg.qwer', 1);
--?INFO:  schema: [PUBLIC], part1: [T_PKG], part2: [QWER], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('syn_pkg.multi_number', 1);
--?INFO:  schema: [PUBLIC], part1: [T_PKG], part2: [MULTI_NUMBER], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('syn_pkg.delete_var', 1);
--?INFO:  schema: [PUBLIC], part1: [T_PKG], part2: [DELETE_VAR], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('syn_pkg.qwer', 1);
--?INFO:  schema: [PUBLIC], part1: [T_PKG], part2: [QWER], dblink: [<NULL>], part1_type: 9, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

--  test trigger
call test_name_resolve('public.log_resolve_after_insert', 3);
--?INFO:  schema: [PUBLIC], part1: [LOG_RESOLVE_AFTER_INSERT], part2: [<NULL>], dblink: [<NULL>], part1_type: 12, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.syn_tg', 3); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('log_resolve_after_insert', 3);
--?INFO:  schema: [PUBLIC], part1: [LOG_RESOLVE_AFTER_INSERT], part2: [<NULL>], dblink: [<NULL>], part1_type: 12, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('syn_tg', 3); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
-- test sequence
call test_name_resolve('public.t_seq', 2);
--?INFO:  schema: [PUBLIC], part1: [T_SEQ], part2: [<NULL>], dblink: [<NULL>], part1_type: 6, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.syn_seq', 2);
--?INFO:  schema: [PUBLIC], part1: [T_SEQ], part2: [<NULL>], dblink: [<NULL>], part1_type: 6, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('t_seq', 2);
--?INFO:  schema: [PUBLIC], part1: [T_SEQ], part2: [<NULL>], dblink: [<NULL>], part1_type: 6, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('syn_seq', 2);
--?INFO:  schema: [PUBLIC], part1: [T_SEQ], part2: [<NULL>], dblink: [<NULL>], part1_type: 6, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.t_seq', 0); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('public.t_seq', 7);
--?INFO:  schema: [PUBLIC], part1: [T_SEQ], part2: [<NULL>], dblink: [<NULL>], part1_type: 13, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.t_seq', 9); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
-- test type
call test_name_resolve('public.t_typ', 7);
--?INFO:  schema: [PUBLIC], part1: [T_TYP], part2: [<NULL>], dblink: [<NULL>], part1_type: 13, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.syn_typ', 7);
--?INFO:  schema: [PUBLIC], part1: [T_TYP], part2: [<NULL>], dblink: [<NULL>], part1_type: 13, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('t_typ', 7);
--?INFO:  schema: [PUBLIC], part1: [T_TYP], part2: [<NULL>], dblink: [<NULL>], part1_type: 13, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('syn_typ', 7);
--?INFO:  schema: [PUBLIC], part1: [T_TYP], part2: [<NULL>], dblink: [<NULL>], part1_type: 13, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.t_typ', 0); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('public.t_typ', 2); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('public.t_typ', 9); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
-- test index
call test_name_resolve('public.t_resolve_c1_udx', 9);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE_C1_UDX], part2: [<NULL>], dblink: [<NULL>], part1_type: 1, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('public.syn_idx', 9); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('t_resolve_c1_udx', 9);
--?INFO:  schema: [PUBLIC], part1: [T_RESOLVE_C1_UDX], part2: [<NULL>], dblink: [<NULL>], part1_type: 1, object_number:.*
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('syn_idx', 9); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('public.t_resolve_c1_udx', 0); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('public.t_resolve_c1_udx', 2); -- error
ERROR:  The Object is not exists
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
-- test java
call test_name_resolve('public.java.class', 4);
ERROR:  Unsupported context type: 4
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('public.java.class', 5);
ERROR:  Unsupported context type: 5
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('public.java.class', 6);
ERROR:  Unsupported context type: 6
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('public.java.class', 8);
ERROR:  Unsupported context type: 8
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
-- test with dblink
call test_name_resolve('peer.lokppe.vuumee@ookeyy', 0);
INFO:  schema: [PEER], part1: [LOKPPE], part2: [VUUMEE], dblink: [OOKEYY], part1_type: 0, object_number: 0
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('peer@ookeyy', 1);
INFO:  schema: [PEER], part1: [<NULL>], part2: [<NULL>], dblink: [OOKEYY], part1_type: 0, object_number: 0
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('peer@ookeyy', 2);
INFO:  schema: [PEER], part1: [<NULL>], part2: [<NULL>], dblink: [OOKEYY], part1_type: 0, object_number: 0
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('peer.@ookeyy', 3); -- error
ERROR:  Invalid input value "peer.@ookeyy" with special words
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('peer.lokppe@ookeyy', 7);
INFO:  schema: [PEER], part1: [LOKPPE], part2: [<NULL>], dblink: [OOKEYY], part1_type: 0, object_number: 0
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('peer.lokppe@ookeyy', 9);
INFO:  schema: [PEER], part1: [LOKPPE], part2: [<NULL>], dblink: [OOKEYY], part1_type: 0, object_number: 0
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('peer.lokppe@ookeyy', 10);
INFO:  schema: [PEER], part1: [LOKPPE], part2: [<NULL>], dblink: [OOKEYY], part1_type: 0, object_number: 0
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('"look"@"dblink"', 0);
INFO:  schema: [look], part1: [<NULL>], part2: [<NULL>], dblink: [dblink], part1_type: 0, object_number: 0
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('lo ok@dbli nk', 0); -- error
ERROR:  Invalid input value "lo ok@dbli nk" with special character
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('lo=ok@dbli nk', 0); -- error
ERROR:  Invalid input value "lo=ok@dbli nk" with special character
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('"123bac"@dblink', 0);
INFO:  schema: [123bac], part1: [<NULL>], part2: [<NULL>], dblink: [DBLINK], part1_type: 0, object_number: 0
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('"@bac"@dblink', 0);
INFO:  schema: [@bac], part1: [<NULL>], part2: [<NULL>], dblink: [DBLINK], part1_type: 0, object_number: 0
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('"!#$%^&*()_-+={}@[]|\:;'',<>./?~`"@dblink', 0);
INFO:  schema: [!#$%^&*()_-+={}@[]|\:;',<>./?~`], part1: [<NULL>], part2: [<NULL>], dblink: [DBLINK], part1_type: 0, object_number: 0
 test_name_resolve 
-------------------
 
(1 row)

-- test context float
call test_name_resolve('peer.lokppe.vuumee@ookeyy', 1.5);
ERROR:  context argument must be integer number
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('peer.lokppe.vuumee@ookeyy', 3.0);
INFO:  schema: [PEER], part1: [LOKPPE], part2: [VUUMEE], dblink: [OOKEYY], part1_type: 0, object_number: 0
 test_name_resolve 
-------------------
 
(1 row)

call test_name_resolve('peer.lokppe.vuumee@ookeyy', 3.05);
ERROR:  context argument must be integer number
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('peer.lokppe.vuumee@ookeyy', 11);
ERROR:  context argument must be number 0 to 10
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
call test_name_resolve('peer.lokppe.vuumee@ookeyy', -1);
ERROR:  context argument must be number 0 to 10
CONTEXT:  PL/pgSQL function gms_utility.name_resolve(character varying,numeric) line 4 at assignment
SQL statement "CALL gms_utility.name_resolve(input,context,schema,part1,part2,dblink,part1_type,object_number)"
PL/pgSQL function test_name_resolve(character varying,numeric) line 8 at SQL statement
DROP SYNONYM syn_tbl;
DROP SYNONYM syn_idx;
DROP SYNONYM syn_seq;
DROP SYNONYM syn_fun;
DROP SYNONYM syn_pro;
DROP SYNONYM syn_tg;
DROP SYNONYM syn_pkg;
DROP SYNONYM syn_typ;
DROP TYPE public.t_typ;
DROP PACKAGE BODY public.t_pkg;
DROP PACKAGE public.t_pkg;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to function public.multi_number(integer,integer)
drop cascades to function public.delete_val(integer)
DROP TRIGGER log_resolve_after_insert ON t_resolve;
DROP FUNCTION public.tg_log;
DROP FUNCTION public.add_numbers;
DROP PROCEDURE public.insert_val;
DROP INDEX public.t_resolve_c1_udx;
DROP TABLE public.t_log;
DROP TABLE public.t_resolve;
DROP SEQUENCE public.t_seq;
---------------------------
-- format error stack
---------------------------
select gms_utility.format_error_stack();
 format_error_stack 
--------------------
 
(1 row)

select gms_utility.format_error_stack(100);
ERROR:  function gms_utility.format_error_stack(integer) does not exist
LINE 1: select gms_utility.format_error_stack(100);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: format_error_stack
create or replace function t_inner(a int, b int)
returns int as $$
declare
    res int := 0;
begin
    res = a / b;
    return res;
exception
    when others then
    raise exception 'expected exception';
end;
$$ language plpgsql;
create or replace function t_outter(a int, b int)
returns int as $$
declare
    res int := 0;
begin
    res := t_inner(a, b);
    return res;
exception
    when others then
    gms_output.put_line(gms_utility.format_error_stack());
    return -1;
end;
$$ language plpgsql;
select t_outter(100, 2);
 t_outter 
----------
       50
(1 row)

select t_outter(100, 0);
16777248: expected exception
PL/pgSQL function t_outter(integer,integer) line 5 at assignment
referenced column: t_outter
 t_outter 
----------
       -1
(1 row)

create table t_error_log (
    pro_name varchar2(300),
    error_desc varchar2(2000),
    exec_date date
);
create table test_error_stack(id int unique);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_error_stack_id_key" for table "test_error_stack"
insert into test_error_stack values(1);
create or replace procedure pr_error_code_test is
    v_backtrace varchar2(1000);
    v_error varchar2(2000);
begin
    begin
        insert into test_error_stack (id) values (1);
        commit;
    exception
        when others then
            raise;
    end;
exception
    when others then
        v_backtrace := gms_utility.format_error_stack;
        v_error := '异常错误为:' || v_backtrace;
        insert into t_error_log (pro_name, error_desc, exec_date)
        values ('pr_error_code_test', v_error, sysdate);
end pr_error_code_test;
/
call pr_error_code_test();
 pr_error_code_test 
--------------------
 
(1 row)

select pro_name, error_desc from t_error_log;
      pro_name      |                                          error_desc                                           
--------------------+-----------------------------------------------------------------------------------------------
 pr_error_code_test | 异常错误为:83906754: duplicate key value violates unique constraint "test_error_stack_id_key"+
                    | SQL statement "insert into test_error_stack (id) values (1)"                                 +
                    | PL/pgSQL function pr_error_code_test() line 5 at SQL statement
(1 row)

declare
    v_str varchar2(10) := '123';
    v_num number;
    v_error_backtrace varchar2(10);
begin
    v_num := to_number(v_str);
    v_error_backtrace := gms_utility.format_error_stack;
    gms_output.put_line('backtrace: ' || v_error_backtrace);
exception
    when others then
        v_error_backtrace := gms_utility.format_error_stack;
        gms_output.put_line('backtrace: ' || v_error_backtrace);
end;
/
backtrace: 
drop procedure pr_error_code_test;
drop table t_error_log;
drop table test_error_stack;
-- test stack overflow
create or replace procedure t_recursion(count in out int)
as
begin
    if count < 1000 then
        count := count + 1;
        t_recursion(count);
    else
        t_inner(100, 0);
    end if;
exception
    when others then
    gms_output.put_line(gms_utility.format_error_stack());
end;
/
declare
    c int := 0;
begin
    t_recursion(c);
end;
/
16777477: stack depth limit exceeded
drop procedure t_recursion;
drop function t_outter;
drop function t_inner;
---------------------------
-- format error backtrace
---------------------------
select gms_utility.format_error_backtrace();
 format_error_backtrace 
------------------------
 
(1 row)

select gms_utility.format_error_backtrace(100);
ERROR:  function gms_utility.format_error_backtrace(integer) does not exist
LINE 1: select gms_utility.format_error_backtrace(100);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: format_error_backtrace
create or replace function t_inner(a int, b int)
returns int as $$
declare
    res int := 0;
begin
    res = a / b;
    return res;
exception
    when others then
    raise exception 'expected exception';
end;
$$ language plpgsql;
create or replace function t_outter(a int, b int)
returns int as $$
declare
    res int := 0;
begin
    res := t_inner(a, b);
    return res;
exception
    when others then
    gms_output.put_line(gms_utility.format_error_backtrace());
    return -1;
end;
$$ language plpgsql;
select t_outter(100, 2);
 t_outter 
----------
       50
(1 row)

select t_outter(100, 0);
16777248: PL/pgSQL function t_outter(integer,integer) line 5 at assignment
16777248: referenced column: t_outter

 t_outter 
----------
       -1
(1 row)

create table t_error_log (
    pro_name varchar2(300),
    error_desc varchar2(2000),
    exec_date date
);
create table test_error_stack(id int unique);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_error_stack_id_key" for table "test_error_stack"
insert into test_error_stack values(1);
create or replace procedure pr_error_code_test is
    v_backtrace varchar2(1000);
    v_error varchar2(2000);
begin
    begin
        insert into test_error_stack (id) values (1);
        commit;
    exception
        when others then
            raise;
    end;
exception
    when others then
        v_backtrace := gms_utility.format_error_backtrace;
        v_error := '异常错误为:' || v_backtrace;
        insert into t_error_log (pro_name, error_desc, exec_date)
        values ('pr_error_code_test', v_error, sysdate);
end pr_error_code_test;
/
call pr_error_code_test();
 pr_error_code_test 
--------------------
 
(1 row)

select pro_name, error_desc from t_error_log;
      pro_name      |                                     error_desc                                      
--------------------+-------------------------------------------------------------------------------------
 pr_error_code_test | 异常错误为:83906754: PL/pgSQL function pr_error_code_test() line 5 at SQL statement+
                    | 
(1 row)

declare
    v_str varchar2(10) := '123';
    v_num number;
    v_error_backtrace varchar2(10);
begin
    v_num := to_number(v_str);
    v_error_backtrace := gms_utility.format_error_backtrace;
    gms_output.put_line('backtrace: ' || v_error_backtrace);
exception
    when others then
        v_error_backtrace := gms_utility.format_error_backtrace;
        gms_output.put_line('backtrace: ' || v_error_backtrace);
end;
/
backtrace: 
drop procedure pr_error_code_test;
drop table t_error_log;
drop table test_error_stack;
-- test stack overflow
create or replace procedure t_recursion(count in out int, max in int)
as
begin
    if count < max then
        count := count + 1;
        t_recursion(count, max);
    else
        t_inner(100, 0);
    end if;
exception
    when others then
    gms_output.put_line(gms_utility.format_error_backtrace());
end;
/
declare
    c int := 0;
begin
    t_recursion(c, 5);
end;
/
16777248: PL/pgSQL function t_recursion(integer,integer) line 6 at PERFORM
16777248: PL/pgSQL function t_recursion(integer,integer) line 4 at SQL statement
16777248: PL/pgSQL function t_recursion(integer,integer) line 4 at SQL statement
16777248: PL/pgSQL function t_recursion(integer,integer) line 4 at SQL statement
16777248: PL/pgSQL function t_recursion(integer,integer) line 4 at SQL statement
16777248: PL/pgSQL function t_recursion(integer,integer) line 4 at SQL statement
16777248: PL/pgSQL function inline_code_block line 3 at SQL statement

drop procedure t_recursion;
drop function t_outter;
drop function t_inner;
---------------------------
-- format call stack
---------------------------
select gms_utility.format_call_stack();
 format_call_stack 
-------------------
 
(1 row)

select gms_utility.format_call_stack(100);
ERROR:  function gms_utility.format_call_stack(integer) does not exist
LINE 1: select gms_utility.format_call_stack(100);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: format_call_stack
create or replace function t_inner
returns void as $$
begin
    gms_output.put_line('t_inner call stack: ');
    gms_output.put_line(gms_utility.format_call_stack());
end;
$$ language plpgsql;
create or replace function t_outter
returns void as $$
begin
    t_inner();
end;
$$ language plpgsql;
select t_inner();
t_inner call stack: 
         4    t_inner()

 t_inner 
---------
 
(1 row)

select t_outter();
t_inner call stack: 
         4    t_inner()
         3    t_outter()

 t_outter 
----------
 
(1 row)

create or replace procedure t_recursion (count in out int, max in int) 
as
begin
    if count < max then
        count := count + 1;
        t_recursion(count, max);
    else
        t_inner();
    end if;
end;
/
declare
    count int := 0;
begin
    t_recursion(count, 5);
end;
/
t_inner call stack: 
         4    t_inner()
         6    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         3    inline_code_block

declare
    count int := 0;
begin
    t_recursion(count, 20);
end;
/
t_inner call stack: 
         4    t_inner()
         6    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         4    t_recursion(integer,integer)
         3    inline_code_block

drop procedure t_recursion;
drop function t_outter;
drop function t_inner;
---------------------------
-- get time
---------------------------
select gms_utility.get_time();
  get_time  
------------
--?.*
(1 row)

select gms_utility.get_time(100);
ERROR:  function gms_utility.get_time(integer) does not exist
LINE 1: select gms_utility.get_time(100);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: get_time
declare
    t1 number;
    t2 number;
    td number;
    sum bigint := 0;
    i int := 0;
begin
    t1 = gms_utility.get_time();
    for i in 1..1000000 loop
        sum := sum + i * 2 - i / 2;
    end loop;
    t2 = gms_utility.get_time();
    td = t2 - t1;
    gms_output.put_line('costtime: ' || td);
end;
/
--?costtime:.*
---------------------------
-- comma to table
---------------------------
create or replace procedure test_comma_to_table(list in varchar2)
as
    tablen binary_integer := 0;
    tab varchar2[];
    i int;
begin
    gms_utility.comma_to_table(list, tablen, tab);
    gms_output.put_line('table len: ' || tablen);
    for i in 1..tablen loop
        gms_output.put_line('tablename: ' || tab(i));
    end loop;
end;
/
call test_comma_to_table('gaussdb.dept');
table len: 1
tablename: gaussdb.dept
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaussdb.dept, gaussdb.emp, gaussdb.jobhist');
table len: 3
tablename: gaussdb.dept
tablename:  gaussdb.emp
tablename:  gaussdb.jobhist
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('  gaussdb.dept, gaussdb.emp, gaussdb.jobhist  ');
table len: 3
tablename: gaussdb.dept
tablename:  gaussdb.emp
tablename:  gaussdb.jobhist  
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaussdb.dept,    gaussdb.emp, gaussdb.jobhist');
table len: 3
tablename: gaussdb.dept
tablename:     gaussdb.emp
tablename:  gaussdb.jobhist
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table(NULL); -- error
ERROR:  Invalid comma-separated list
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table(''); -- error
ERROR:  Invalid comma-separated list
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('    '); -- error
ERROR:  Invalid comma-separated list
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('"     "');
table len: 1
tablename: "     "
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaus  sdb.dept'); -- error
ERROR:  Invalid parameter value "gaus  sdb.dept"
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('"gaus  sdb".dept');
table len: 1
tablename: "gaus  sdb".dept
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaussdb.dept,,gaussdb.emp'); -- error
ERROR:  Invalid comma-separated list
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gaussdb.dept,gaussdb.emp,'); -- error
ERROR:  Invalid comma-separated list
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gaussdb..dept,gaussdb.emp'); -- error
ERROR:  Invalid parameter value "gaussdb..dept" with special words
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gaussdb.dept@dblink,gaussdb.emp'); -- error
ERROR:  Invalid parameter value "gaussdb.dept@dblink" with special character
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gaussdb.dept_dblink,gaussdb.emp');
table len: 2
tablename: gaussdb.dept_dblink
tablename: gaussdb.emp
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaussdb.dept$dblink,gaussdb.emp');
table len: 2
tablename: gaussdb.dept$dblink
tablename: gaussdb.emp
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaussdb.dept#dblink,gaussdb.emp');
table len: 2
tablename: gaussdb.dept#dblink
tablename: gaussdb.emp
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaussdb.dept123dblink,gaussdb.emp');
table len: 2
tablename: gaussdb.dept123dblink
tablename: gaussdb.emp
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaussdb._deptdblink,gaussdb.emp'); -- ok for og, error for a
table len: 2
tablename: gaussdb._deptdblink
tablename: gaussdb.emp
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaussdb.$deptdblink,gaussdb.emp'); -- error
ERROR:  Invalid parameter value "gaussdb.$deptdblink" with special words
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gaussdb."$deptdblink",gaussdb.emp');
table len: 2
tablename: gaussdb."$deptdblink"
tablename: gaussdb.emp
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaussdb.#deptdblink,gaussdb.emp'); -- error
ERROR:  Invalid parameter value "gaussdb.#deptdblink" with special words
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gaussdb."#deptdblink",gaussdb.emp');
table len: 2
tablename: gaussdb."#deptdblink"
tablename: gaussdb.emp
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaussdb.123deptdblink,gaussdb.emp'); -- error
ERROR:  Invalid parameter value "gaussdb.123deptdblink" with special words
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gaussdb."123deptdblink",gaussdb.emp');
table len: 2
tablename: gaussdb."123deptdblink"
tablename: gaussdb.emp
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('123,gaussdb.emp'); -- error
ERROR:  Invalid parameter value "123" with special words
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('123.abc,gaussdb.emp'); -- error
ERROR:  Invalid parameter value "123.abc" with special words
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gaussdb.DoYouThinkCausalUnderstandingIsADefiningCharacteristicOfHumanCognition,gaussdb.emp'); -- error
ERROR:  identifier too long, max length is 63
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gaussdb.table,gaussdb.emp'); -- error
ERROR:  Invalid parameter value "gaussdb.table" with special words
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gaussdb."table",gaussdb.emp');
table len: 2
tablename: gaussdb."table"
tablename: gaussdb.emp
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('gaussdb.column,gaussdb.emp'); -- error
ERROR:  Invalid parameter value "gaussdb.column" with special words
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gaussdb."column",gaussdb.emp');
table len: 2
tablename: gaussdb."column"
tablename: gaussdb.emp
 test_comma_to_table 
---------------------
 
(1 row)

call test_comma_to_table('"gaussdb.dept,gaussdb.emp"'); -- error
ERROR:  Invalid parameter value ""gaussdb.dept" with quotation not closed
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('"gauss"db.d"ept,gaussdb.emp'); -- error
ERROR:  Invalid parameter value ""gauss"db.d"ept" after quotation
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
call test_comma_to_table('gauss"db".dept,gaussdb.emp'); -- error
ERROR:  Invalid parameter value "gauss"db".dept" before quotation
CONTEXT:  PL/pgSQL function gms_utility.comma_to_table(character varying) line 4 at assignment
SQL statement "CALL gms_utility.comma_to_table(list,tablen,tab)"
PL/pgSQL function test_comma_to_table(character varying) line 5 at SQL statement
drop procedure test_comma_to_table;
---------------------------
-- exec_ddl_statement
---------------------------
call gms_utility.exec_ddl_statement('create table public.t_exec_ddl (c1 int, c2 text);');
 exec_ddl_statement 
--------------------
 
(1 row)

call gms_utility.exec_ddl_statement('alter table public.t_exec_ddl add column c3 boolean default true');
 exec_ddl_statement 
--------------------
 
(1 row)

-- test no ddl sql
call gms_utility.exec_ddl_statement('insert into public.t_exec_ddl values (1, 234, 1)'); -- error
ERROR:  Unsupported query type, only support DDL query
CONTEXT:  SQL statement "CALL gms_utility.exec_ddl_statement_c_func(parse_string)"
PL/pgSQL function gms_utility.exec_ddl_statement(character varying) line 2 at PERFORM
call gms_utility.exec_ddl_statement('update public.t_exec_ddl set c2 = 666'); -- error
ERROR:  Unsupported query type, only support DDL query
CONTEXT:  SQL statement "CALL gms_utility.exec_ddl_statement_c_func(parse_string)"
PL/pgSQL function gms_utility.exec_ddl_statement(character varying) line 2 at PERFORM
call gms_utility.exec_ddl_statement('select * from public.t_exec_ddl;'); -- error
ERROR:  Unsupported query type, only support DDL query
CONTEXT:  SQL statement "CALL gms_utility.exec_ddl_statement_c_func(parse_string)"
PL/pgSQL function gms_utility.exec_ddl_statement(character varying) line 2 at PERFORM
-- test invalid sql
call gms_utility.exec_ddl_statement('today is a good day!'); -- error
ERROR:  syntax error at or near "today"
LINE 1: CALL gms_utility.exec_ddl_statement_c_func(parse_string)
        ^
QUERY:  CALL gms_utility.exec_ddl_statement_c_func(parse_string)
CONTEXT:  PL/pgSQL function gms_utility.exec_ddl_statement(character varying) line 2 at PERFORM
call gms_utility.exec_ddl_statement(''); -- error
ERROR:  Invalid input value
CONTEXT:  SQL statement "CALL gms_utility.exec_ddl_statement_c_func(parse_string)"
PL/pgSQL function gms_utility.exec_ddl_statement(character varying) line 2 at PERFORM
call gms_utility.exec_ddl_statement(null); -- error
ERROR:  Invalid input value
CONTEXT:  SQL statement "CALL gms_utility.exec_ddl_statement_c_func(parse_string)"
PL/pgSQL function gms_utility.exec_ddl_statement(character varying) line 2 at PERFORM
call gms_utility.exec_ddl_statement('alter table public.t_exec_ddl drop column c3; alter table public.t_exec_ddl add column c3 boolean default true;');
ERROR:  Exec_ddl_statement only support one query
CONTEXT:  SQL statement "CALL gms_utility.exec_ddl_statement_c_func(parse_string)"
PL/pgSQL function gms_utility.exec_ddl_statement(character varying) line 2 at PERFORM
call gms_utility.exec_ddl_statement('create table public.t_exec_ddl (c1 int, c2 text);'); -- error
ERROR:  relation "t_exec_ddl" already exists in schema "public"
DETAIL:  creating new table with existing name in the same schema
CONTEXT:  SQL statement "create table public.t_exec_ddl (c1 int, c2 text);"
SQL statement "CALL gms_utility.exec_ddl_statement_c_func(parse_string)"
PL/pgSQL function gms_utility.exec_ddl_statement(character varying) line 2 at PERFORM
call gms_utility.exec_ddl_statement('drop table public.t_exec_ddl');
 exec_ddl_statement 
--------------------
 
(1 row)

call gms_utility.exec_ddl_statement(); -- error
ERROR:  function "exec_ddl_statement" with 0 parameters doesn't exist 
call gms_utility.exec_ddl_statement('create table public.t_exec_ddl2 (c1 int, c2 text);', 'test'); -- error
ERROR:  function "exec_ddl_statement" with 2 parameters doesn't exist 
declare 
    parse_string date:='2024-10-1';
begin
    gms_utility.exec_ddl_statement(parse_string);
end; -- error
/
ERROR:  syntax error at or near "Tue"
LINE 1: CALL gms_utility.exec_ddl_statement_c_func(parse_string)
        ^
QUERY:  CALL gms_utility.exec_ddl_statement_c_func(parse_string)
CONTEXT:  PL/pgSQL function gms_utility.exec_ddl_statement(character varying) line 2 at PERFORM
SQL statement "CALL gms_utility.exec_ddl_statement(parse_string)"
PL/pgSQL function inline_code_block line 3 at PERFORM
---------------------------
-- get_hash_value
---------------------------
select gms_utility.get_hash_value('Today is a good day', 1000, 1024);
 get_hash_value 
----------------
           1054
(1 row)

select gms_utility.get_hash_value('Today is a good day', NULL, 2048); -- error
ERROR:  Invalid input parameter "base" 
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('Today is a good day', '', 2048); -- error
ERROR:  Invalid input parameter "base" 
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('Today is a good day', 1000, NULL); -- error
ERROR:  Invalid input parameter "hash_size" 
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('Today is a good day', 1000, ''); -- error
ERROR:  Invalid input parameter "hash_size" 
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('Today is a good day', 1000, 0); -- error
ERROR:  Param "hash_size" can't less than 0
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('Today is a good day', 0, 2048);
 get_hash_value 
----------------
             54
(1 row)

select gms_utility.get_hash_value('Today is a good day', -1000, 2048);
 get_hash_value 
----------------
           -946
(1 row)

select gms_utility.get_hash_value('Today is a good day', 2147483647, 2048);
 get_hash_value 
----------------
    -2147483595
(1 row)

select gms_utility.get_hash_value('Today is a good day', 2147483648, 2048); -- error, OVER int32
ERROR:  integer out of range
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('Today is a good day', 1024, 2147483647);
 get_hash_value 
----------------
      675812406
(1 row)

select gms_utility.get_hash_value('Today is a good day', 1024, 2147483648); -- error, OVER int32
ERROR:  integer out of range
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('Today is a good day', 1024, -2147483648.4); -- error, OVER int32
ERROR:  Param "hash_size" can't less than 0
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value(null, 1000, 1024);
 get_hash_value 
----------------
           1621
(1 row)

select gms_utility.get_hash_value('', 1000, 1024);
 get_hash_value 
----------------
           1621
(1 row)

select gms_utility.get_hash_value('select 1;', 0, 100);
 get_hash_value 
----------------
             21
(1 row)

select gms_utility.get_hash_value(); -- error
ERROR:  function gms_utility.get_hash_value() does not exist
LINE 1: select gms_utility.get_hash_value();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('2024-11-27'); -- error
ERROR:  function gms_utility.get_hash_value(unknown) does not exist
LINE 1: select gms_utility.get_hash_value('2024-11-27');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('2024-11-27', 'test'); -- error
ERROR:  function gms_utility.get_hash_value(unknown, unknown) does not exist
LINE 1: select gms_utility.get_hash_value('2024-11-27', 'test');
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('2024-11-27', 0); -- error
ERROR:  function gms_utility.get_hash_value(unknown, integer) does not exist
LINE 1: select gms_utility.get_hash_value('2024-11-27', 0);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('2024-11-27', 0, 'test'); -- error
ERROR:  invalid input syntax for type numeric: "test"
LINE 1: select gms_utility.get_hash_value('2024-11-27', 0, 'test');
                                                           ^
CONTEXT:  referenced column: get_hash_value
select gms_utility.get_hash_value('2024-11-27', 0, 100, 200); -- error
ERROR:  function gms_utility.get_hash_value(unknown, integer, integer, integer) does not exist
LINE 1: select gms_utility.get_hash_value('2024-11-27', 0, 100, 200)...
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: get_hash_value
---------------------------
-- table_to_comma
---------------------------
declare
    tab varchar2[];
    tablen  integer;
    list    varchar2;
begin
    tab(1) := '';
    gms_utility.table_to_comma(tab, tablen, list);
    gms_output.put_line('tablen: '|| tablen ||', result: '|| list);
end; -- error
/
ERROR:  function 395 returned NULL
CONTEXT:  PL/pgSQL function gms_utility.table_to_comma(character varying[]) line 5 at assignment
SQL statement "CALL gms_utility.table_to_comma(tab,tablen,list)"
PL/pgSQL function inline_code_block line 6 at SQL statement
declare
    tablen  integer;
    list    varchar2;
begin
    gms_utility.table_to_comma(NULL, tablen, list);
    gms_output.put_line('tablen: '|| tablen ||', result: '|| list);
end; -- error
/
ERROR:  Invalid Input value
CONTEXT:  PL/pgSQL function gms_utility.table_to_comma(character varying[]) line 5 at assignment
SQL statement "CALL gms_utility.table_to_comma(NULL,tablen,list)"
PL/pgSQL function inline_code_block line 4 at SQL statement
declare
    tab varchar2[];
    tablen  integer;
    list    varchar2;
begin
    tab(1) := 'build';
    tab(2) := 'test';
    tab(3) := 'date';
    gms_utility.table_to_comma(tab, tablen, list);
    gms_output.put_line('tablen: '|| tablen ||', result: '|| list);
end;
/
tablen: 3, result: build,test,date
declare
    tab varchar2[];
    tablen  integer;
    list    varchar2;
begin
    tab(1) := '  build';
    tab(2) := 'test  ';
    tab(3) := '  date';
    gms_utility.table_to_comma(tab, tablen, list);
    gms_output.put_line('tablen: '|| tablen ||', result: '|| list);
end;
/
tablen: 3, result:   build,test  ,  date
declare
    tab varchar2[];
    tablen  integer;
    list    varchar2;
begin
    tab(1) := '@build';
    tab(2) := '$test  ';
    tab(3) := '-  date';
    gms_utility.table_to_comma(tab, tablen, list);
    gms_output.put_line('tablen: '|| tablen ||', result: '|| list);
end;
/
tablen: 3, result: @build,$test  ,-  date
declare
    tab varchar2[];
    tablen  integer;
    list    varchar2;
begin
    tab(1) := '123build';
    tab(2) := '(test  ';
    tab(3) := '&date';
    gms_utility.table_to_comma(tab, tablen, list);
    gms_output.put_line('tablen: '|| tablen ||', result: '|| list);
end;
/
tablen: 3, result: 123build,(test  ,&date
declare
    tab varchar2[];
    tablen  integer;
    list    varchar2;
begin
    tab(1) := '123build';
    tab(2) := '(test  ';
    tab(3) := '&date';
    gms_utility.table_to_comma(tab, tablen, list);
    gms_output.put_line('tablen: '|| tablen ||', result: '|| list);
end;
/
tablen: 3, result: 123build,(test  ,&date
declare
    tab varchar2[];
    tablen  integer;
    list    varchar2;
begin
    tab(1) := 'table';
    gms_utility.table_to_comma(tab, tablen, list);
    gms_output.put_line('tablen: '|| tablen ||', result: '|| list);
end;
/
tablen: 1, result: table
declare
    tab varchar2;
    tablen  integer;
    list    varchar2;
begin
    tab := 'table';
    gms_utility.table_to_comma(tab, tablen, list);
    gms_output.put_line('tablen: '|| tablen ||', result: '|| list);
end; -- error
/
ERROR:  function gms_utility.table_to_comma(character varying) does not exist
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  SQL statement "CALL gms_utility.table_to_comma(tab,tablen,list)"
PL/pgSQL function inline_code_block line 6 at SQL statement
declare
    tab varchar2[];
    tablen  integer;
begin
    tab(1) := 'build';
    gms_utility.table_to_comma(tab, tablen);
end; -- error
/
ERROR:  function "table_to_comma" with 2 parameters doesn't exist 
CONTEXT:  SQL statement "CALL gms_utility.table_to_comma(tab,tablen)"
PL/pgSQL function inline_code_block line 5 at SQL statement
reset behavior_compat_options;
drop extension gms_output;
drop extension gms_utility cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table gms_utility.t_into
drop cascades to table gms_utility.num
reset search_path;
